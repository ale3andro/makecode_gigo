/// <reference path="../localtypings/vscode-debug-protocol.d.ts" />
/// <reference path="../localtypings/pxtparts.d.ts" />
/// <reference path="../localtypings/pxtarget.d.ts" />
/// <reference path="../localtypings/pxtmusic.d.ts" />
declare namespace pxsim.accessibility {
    function makeFocusable(elem: SVGElement): void;
    function getGlobalAction(e: KeyboardEvent): pxsim.GlobalAction | null;
    function postKeyboardEvent(): void;
    function enableKeyboardInteraction(elem: Element, handlerKeyDown?: () => void, handlerKeyUp?: () => void): void;
    function setAria(elem: Element, role?: string, label?: string): void;
    function setLiveContent(value: string): void;
}
declare namespace pxsim {
    interface AllocatorOpts {
        boardDef: BoardDefinition;
        partDefs: Map<PartDefinition>;
        partsList: string[];
        fnArgs: any;
        getBBCoord: (loc: BBLoc) => visuals.Coord;
    }
    interface AllocatorResult {
        partsAndWires: PartAndWiresInst[];
        requiresBreadboard?: boolean;
        hideBreadboard?: boolean;
        parts: pxsim.visuals.IBoardPart<any>[];
        wires: pxsim.visuals.Wire[];
    }
    interface PartInst {
        name: string;
        simulationBehavior?: string;
        visual: PartVisualDefinition;
        bbFit: PartBBFit;
        startColumnIdx: number;
        startRowIdx: number;
        breadboardConnections: BBLoc[];
        params: Map<string>;
    }
    interface WireInst {
        start: Loc;
        end: Loc;
        color: string;
    }
    interface AssemblyStep {
        part?: boolean;
        wireIndices?: number[];
    }
    interface PartAndWiresInst {
        part?: PartInst;
        wires?: WireInst[];
        assembly: AssemblyStep[];
    }
    interface PartBBFit {
        xOffset: number;
        yOffset: number;
        rowCount: number;
        colCount: number;
    }
    function readPin(arg: string): string;
    function allocateDefinitions(opts: AllocatorOpts): AllocatorResult;
}
/**
 * Heavily adapted from https://github.com/microsoft/vscode-debugadapter-node
 * and altered to run in a browser and communcate via JSON over a websocket
 * rather than through stdin and stdout
 */
declare namespace pxsim.protocol {
    /**
     * Host for debug session that is responsible with communication with
     * the debugger's user interface.
     */
    interface DebugSessionHost {
        send(msg: string): void;
        onData(cb: (msg: DebugProtocol.ProtocolMessage) => void): void;
        onError(cb: (e?: any) => void): void;
        onClose(cb: () => void): void;
        close(): void;
    }
    class Message implements DebugProtocol.ProtocolMessage {
        seq: number;
        type: string;
        constructor(type: string);
    }
    class Response extends Message implements DebugProtocol.Response {
        request_seq: number;
        success: boolean;
        command: string;
        constructor(request: DebugProtocol.Request, message?: string);
    }
    class Event extends Message implements DebugProtocol.Event {
        event: string;
        constructor(event: string, body?: any);
    }
    class Source implements DebugProtocol.Source {
        name: string;
        path: string;
        sourceReference: number;
        constructor(name: string, path: string, id?: number, origin?: string, data?: any);
    }
    class Scope implements DebugProtocol.Scope {
        name: string;
        variablesReference: number;
        expensive: boolean;
        constructor(name: string, reference: number, expensive?: boolean);
    }
    class StackFrame implements DebugProtocol.StackFrame {
        id: number;
        source: Source;
        line: number;
        column: number;
        name: string;
        constructor(i: number, nm: string, src?: Source, ln?: number, col?: number);
    }
    class Thread implements DebugProtocol.Thread {
        id: number;
        name: string;
        constructor(id: number, name: string);
    }
    class Variable implements DebugProtocol.Variable {
        name: string;
        value: string;
        variablesReference: number;
        constructor(name: string, value: string, ref?: number, indexedVariables?: number, namedVariables?: number);
    }
    class Breakpoint implements DebugProtocol.Breakpoint {
        verified: boolean;
        constructor(verified: boolean, line?: number, column?: number, source?: Source);
    }
    class Module implements DebugProtocol.Module {
        id: number | string;
        name: string;
        constructor(id: number | string, name: string);
    }
    class CompletionItem implements DebugProtocol.CompletionItem {
        label: string;
        start: number;
        length: number;
        constructor(label: string, start: number, length?: number);
    }
    class StoppedEvent extends Event implements DebugProtocol.StoppedEvent {
        body: {
            reason: string;
            threadId: number;
        };
        constructor(reason: string, threadId: number, exception_text?: string);
    }
    class ContinuedEvent extends Event implements DebugProtocol.ContinuedEvent {
        body: {
            threadId: number;
        };
        constructor(threadId: number, allThreadsContinued?: boolean);
    }
    class InitializedEvent extends Event implements DebugProtocol.InitializedEvent {
        constructor();
    }
    class TerminatedEvent extends Event implements DebugProtocol.TerminatedEvent {
        constructor(restart?: boolean);
    }
    class OutputEvent extends Event implements DebugProtocol.OutputEvent {
        body: {
            category: string;
            output: string;
            data?: any;
        };
        constructor(output: string, category?: string, data?: any);
    }
    class ThreadEvent extends Event implements DebugProtocol.ThreadEvent {
        body: {
            reason: string;
            threadId: number;
        };
        constructor(reason: string, threadId: number);
    }
    class BreakpointEvent extends Event implements DebugProtocol.BreakpointEvent {
        body: {
            reason: string;
            breakpoint: Breakpoint;
        };
        constructor(reason: string, breakpoint: Breakpoint);
    }
    class ModuleEvent extends Event implements DebugProtocol.ModuleEvent {
        body: {
            reason: 'new' | 'changed' | 'removed';
            module: Module;
        };
        constructor(reason: 'new' | 'changed' | 'removed', module: Module);
    }
    class ProtocolServer {
        private host;
        private _pendingRequests;
        private _sequence;
        start(host: DebugSessionHost): void;
        stop(): void;
        sendEvent(event: DebugProtocol.Event): void;
        sendResponse(response: DebugProtocol.Response): void;
        sendRequest(command: string, args: any, timeout: number, cb: (response: DebugProtocol.Response) => void): void;
        private send;
        protected dispatchRequest(request: DebugProtocol.Request): void;
    }
    class DebugSession extends ProtocolServer {
        private _debuggerLinesStartAt1;
        private _debuggerColumnsStartAt1;
        private _debuggerPathsAreURIs;
        private _clientLinesStartAt1;
        private _clientColumnsStartAt1;
        private _clientPathsAreURIs;
        private _isServer;
        shutdown(): void;
        protected dispatchRequest(request: DebugProtocol.Request): void;
        protected initializeRequest(response: DebugProtocol.InitializeResponse, args: DebugProtocol.InitializeRequestArguments): void;
        protected disconnectRequest(response: DebugProtocol.DisconnectResponse, args: DebugProtocol.DisconnectArguments): void;
        protected launchRequest(response: DebugProtocol.LaunchResponse, args: DebugProtocol.LaunchRequestArguments): void;
        protected attachRequest(response: DebugProtocol.AttachResponse, args: DebugProtocol.AttachRequestArguments): void;
        protected setBreakPointsRequest(response: DebugProtocol.SetBreakpointsResponse, args: DebugProtocol.SetBreakpointsArguments): void;
        protected setFunctionBreakPointsRequest(response: DebugProtocol.SetFunctionBreakpointsResponse, args: DebugProtocol.SetFunctionBreakpointsArguments): void;
        protected setExceptionBreakPointsRequest(response: DebugProtocol.SetExceptionBreakpointsResponse, args: DebugProtocol.SetExceptionBreakpointsArguments): void;
        protected configurationDoneRequest(response: DebugProtocol.ConfigurationDoneResponse, args: DebugProtocol.ConfigurationDoneArguments): void;
        protected continueRequest(response: DebugProtocol.ContinueResponse, args: DebugProtocol.ContinueArguments): void;
        protected nextRequest(response: DebugProtocol.NextResponse, args: DebugProtocol.NextArguments): void;
        protected stepInRequest(response: DebugProtocol.StepInResponse, args: DebugProtocol.StepInArguments): void;
        protected stepOutRequest(response: DebugProtocol.StepOutResponse, args: DebugProtocol.StepOutArguments): void;
        protected stepBackRequest(response: DebugProtocol.StepBackResponse, args: DebugProtocol.StepBackArguments): void;
        protected restartFrameRequest(response: DebugProtocol.RestartFrameResponse, args: DebugProtocol.RestartFrameArguments): void;
        protected gotoRequest(response: DebugProtocol.GotoResponse, args: DebugProtocol.GotoArguments): void;
        protected pauseRequest(response: DebugProtocol.PauseResponse, args: DebugProtocol.PauseArguments): void;
        protected sourceRequest(response: DebugProtocol.SourceResponse, args: DebugProtocol.SourceArguments): void;
        protected threadsRequest(response: DebugProtocol.ThreadsResponse): void;
        protected stackTraceRequest(response: DebugProtocol.StackTraceResponse, args: DebugProtocol.StackTraceArguments): void;
        protected scopesRequest(response: DebugProtocol.ScopesResponse, args: DebugProtocol.ScopesArguments): void;
        protected variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void;
        protected setVariableRequest(response: DebugProtocol.SetVariableResponse, args: DebugProtocol.SetVariableArguments): void;
        protected evaluateRequest(response: DebugProtocol.EvaluateResponse, args: DebugProtocol.EvaluateArguments): void;
        protected stepInTargetsRequest(response: DebugProtocol.StepInTargetsResponse, args: DebugProtocol.StepInTargetsArguments): void;
        protected gotoTargetsRequest(response: DebugProtocol.GotoTargetsResponse, args: DebugProtocol.GotoTargetsArguments): void;
        protected completionsRequest(response: DebugProtocol.CompletionsResponse, args: DebugProtocol.CompletionsArguments): void;
        /**
         * Override this hook to implement custom requests.
         */
        protected customRequest(command: string, response: DebugProtocol.Response, args: any): void;
        protected sendErrorResponse(response: DebugProtocol.Response, codeOrMessage: number | DebugProtocol.Message, format?: string, variables?: any): void;
        protected convertClientLineToDebugger(line: number): number;
        protected convertDebuggerLineToClient(line: number): number;
        protected convertClientColumnToDebugger(column: number): number;
        protected convertDebuggerColumnToClient(column: number): number;
        protected convertClientPathToDebugger(clientPath: string): string;
        protected convertDebuggerPathToClient(debuggerPath: string): string;
        private static path2uri;
        private static uri2path;
        private static _formatPIIRegexp;
        private static formatPII;
    }
}
declare namespace pxsim.util {
    function injectPolyphils(): void;
    class Lazy<T> {
        private _func;
        private _value;
        private _evaluated;
        constructor(_func: () => T);
        get value(): T;
    }
    function getNormalizedParts(path: string): string[];
    function normalizePath(path: string): string;
    function relativePath(fromDir: string, toFile: string): string;
    function pathJoin(...paths: string[]): string;
    function toArray<T>(a: ArrayLike<T> | ReadonlyArray<T>): T[];
}
declare namespace pxsim {
    function getWarningMessage(msg: string): DebuggerWarningMessage;
    class BreakpointMap {
        fileMap: {
            [index: string]: [number, DebugProtocol.Breakpoint][];
        };
        idMap: {
            [index: number]: DebugProtocol.Breakpoint;
        };
        constructor(breakpoints: [number, DebugProtocol.Breakpoint][]);
        getById(id: number): DebugProtocol.Breakpoint;
        verifyBreakpoint(path: string, breakpoint: DebugProtocol.SourceBreakpoint): [number, DebugProtocol.Breakpoint];
    }
    function dumpHeap(v: any, heap: Map<any>, fields?: string[], filters?: string[], includeAll?: boolean): Variables;
    function injectEnvironmentGlobals(msg: DebuggerBreakpointMessage, heap: Map<any>): void;
    function getBreakpointMsg(s: pxsim.StackFrame, brkId: number, userGlobals?: string[]): {
        msg: DebuggerBreakpointMessage;
        heap: Map<any>;
    };
    interface SimLaunchArgs extends DebugProtocol.LaunchRequestArguments {
        projectDir: string;
    }
    class SimDebugSession extends protocol.DebugSession {
        private static THREAD_ID;
        private driver;
        private lastBreak;
        private state;
        private projectDir;
        private breakpoints;
        constructor(container: HTMLElement);
        runCode(js: string, parts: string[], fnArgs: Map<string>, breakpoints: BreakpointMap, board: pxsim.BoardDefinition): void;
        stopSimulator(unload?: boolean): void;
        protected initializeRequest(response: DebugProtocol.InitializeResponse, args: DebugProtocol.InitializeRequestArguments): void;
        protected disconnectRequest(response: DebugProtocol.DisconnectResponse, args: DebugProtocol.DisconnectArguments): void;
        protected launchRequest(response: DebugProtocol.LaunchResponse, args: SimLaunchArgs): void;
        protected setBreakPointsRequest(response: DebugProtocol.SetBreakpointsResponse, args: DebugProtocol.SetBreakpointsArguments): void;
        protected continueRequest(response: DebugProtocol.ContinueResponse, args: DebugProtocol.ContinueArguments): void;
        protected nextRequest(response: DebugProtocol.NextResponse, args: DebugProtocol.NextArguments): void;
        protected stepInRequest(response: DebugProtocol.StepInResponse, args: DebugProtocol.StepInArguments): void;
        protected stepOutRequest(response: DebugProtocol.StepOutResponse, args: DebugProtocol.StepOutArguments): void;
        protected pauseRequest(response: DebugProtocol.PauseResponse, args: DebugProtocol.PauseArguments): void;
        protected threadsRequest(response: DebugProtocol.ThreadsResponse): void;
        protected stackTraceRequest(response: DebugProtocol.StackTraceResponse, args: DebugProtocol.StackTraceArguments): void;
        protected scopesRequest(response: DebugProtocol.ScopesResponse, args: DebugProtocol.ScopesArguments): void;
        protected variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void;
        private onDebuggerBreakpoint;
        private onDebuggerWarning;
        private onDebuggerResume;
        private onStateChanged;
        private fixBreakpoints;
    }
}
declare namespace pxsim {
    interface SimulatorRunMessage extends SimulatorMessage {
        type: "run";
        id?: string;
        boardDefinition?: BoardDefinition;
        frameCounter?: number;
        refCountingDebug?: boolean;
        options?: any;
        parts?: string[];
        builtinParts?: string[];
        partDefinitions?: Map<PartDefinition>;
        fnArgs?: any;
        code: string;
        mute?: boolean;
        highContrast?: boolean;
        light?: boolean;
        cdnUrl?: string;
        localizedStrings?: Map<string>;
        version?: string;
        clickTrigger?: boolean;
        breakOnStart?: boolean;
        storedState?: Map<any>;
        ipc?: boolean;
        dependencies?: Map<string>;
        single?: boolean;
        traceDisabled?: boolean;
        activePlayer?: 1 | 2 | 3 | 4 | undefined;
        theme?: string | pxt.Map<string>;
        yieldDelay?: number;
    }
    interface SimulatorInstructionsMessage extends SimulatorMessage {
        type: "instructions";
        options: pxsim.instructions.RenderPartsOptions;
    }
    interface SimulatorMuteMessage extends SimulatorMessage {
        type: "mute";
        mute: boolean;
    }
    interface SimulatorStopSoundMessage extends SimulatorMessage {
        type: "stopsound";
    }
    interface SimulatorDocMessage extends SimulatorMessage {
        type: "localtoken" | "docfailed";
        docType?: string;
        src?: string;
        localToken?: string;
    }
    interface SimulatorFileLoadedMessage extends SimulatorMessage {
        type: "fileloaded";
        name: string;
        locale: string;
        content?: string;
    }
    interface SimulatorReadyMessage extends SimulatorMessage {
        type: "ready";
        frameid: string;
    }
    interface SimulatorTopLevelCodeFinishedMessage extends SimulatorMessage {
        type: "toplevelcodefinished";
    }
    interface SimulatorOpenDocMessage extends SimulatorMessage {
        type: "opendoc";
        url: string;
    }
    type GlobalAction = "escape" | "toggleareamenu" | "togglekeyboardcontrolshelp";
    interface SimulatorActionMessage extends SimulatorMessage {
        type: "action";
        action: GlobalAction;
    }
    interface SimulatorStateMessage extends SimulatorMessage {
        type: "status";
        frameid?: string;
        runtimeid?: string;
        state: string;
    }
    interface SimulatorBroadcastMessage extends SimulatorMessage {
        broadcast: boolean;
        toParentIFrameOnly?: boolean;
        srcFrameIndex?: number;
    }
    interface SimulatorControlMessage extends SimulatorBroadcastMessage {
        type: "messagepacket";
        channel: string;
        data: Uint8Array;
    }
    interface SimulatorEventBusMessage extends SimulatorBroadcastMessage {
        type: "eventbus";
        broadcast: true;
        id: number;
        eventid: number;
        value?: number;
    }
    interface SimulatorSerialMessage extends SimulatorMessage {
        type: "serial";
        id: string;
        data: string;
        sim?: boolean;
        csvType?: undefined | "headers" | "row" | "clear";
        receivedTime?: number;
    }
    interface SimulatorBulkSerialMessage extends SimulatorMessage {
        type: "bulkserial";
        id: string;
        data: {
            data: string;
            time: number;
        }[];
        sim?: boolean;
    }
    interface SimulatorCommandMessage extends SimulatorMessage {
        type: "simulator";
        command: "modal" | "restart" | "reload" | "setstate" | "focus" | "blur" | "single";
        stateKey?: string;
        stateValue?: any;
        header?: string;
        body?: string;
        copyable?: string;
        linkButtonHref?: string;
        linkButtonLabel?: string;
        displayOnceId?: string;
        modalContext?: string;
        timestamp?: number;
    }
    interface SimulatorRadioPacketMessage extends SimulatorBroadcastMessage {
        type: "radiopacket";
        broadcast: true;
        rssi: number;
        serial: number;
        time: number;
        payload: SimulatorRadioPacketPayload;
    }
    interface SimulatorInfraredPacketMessage extends SimulatorBroadcastMessage {
        type: "irpacket";
        broadcast: true;
        packet: Uint8Array;
    }
    interface SimulatorBLEPacketMessage extends SimulatorBroadcastMessage {
        type: "blepacket";
        broadcast: true;
        packet: Uint8Array;
    }
    interface SimulatorI2CMessage extends SimulatorMessage {
        type: "i2c";
        data: Uint8Array;
    }
    interface SimulatorRadioPacketPayload {
        type: number;
        groupId: number;
        stringData?: string;
        numberData?: number;
    }
    interface SimulatorCustomMessage extends SimulatorMessage {
        type: "custom";
        content: any;
    }
    interface SimulatorScreenshotMessage extends SimulatorMessage {
        type: "screenshot";
        data: ImageData;
        delay?: number;
        modalContext?: string;
    }
    interface SimulatorAutomaticThumbnailMessage extends SimulatorMessage {
        type: "thumbnail";
        frames: ImageData[];
    }
    interface SimulatorAddExtensionsMessage extends SimulatorMessage {
        type: "addextensions";
        /**
         * List of repositories to add
         */
        extensions: string[];
    }
    interface SimulatorAspectRatioMessage extends SimulatorMessage {
        type: "aspectratio";
        value: number;
        frameid: string;
    }
    interface SimulatorRecorderMessage extends SimulatorMessage {
        type: "recorder";
        action: "start" | "stop";
        width?: number;
    }
    interface TutorialMessage extends SimulatorMessage {
        type: "tutorial";
        tutorial: string;
        subtype: string;
    }
    interface ImportFileMessage extends SimulatorMessage {
        type: "importfile";
        filename: string;
        parts: (string | ArrayBuffer)[];
    }
    interface TutorialStepInfo {
        fullscreen?: boolean;
        contentMd?: string;
        headerContentMd?: string;
        hintContentMd?: string;
    }
    interface TutorialLoadedMessage extends TutorialMessage {
        subtype: "loaded";
        showCategories?: boolean;
        stepInfo: TutorialStepInfo[];
        toolboxSubset?: {
            [index: string]: number;
        };
    }
    interface TutorialStepChangeMessage extends TutorialMessage {
        subtype: "stepchange";
        step: number;
    }
    interface TutorialFailedMessage extends TutorialMessage {
        subtype: "error";
        message?: string;
    }
    interface RenderReadyResponseMessage extends SimulatorMessage {
        source: "makecode";
        type: "renderready";
        versions: pxt.TargetVersions;
    }
    interface RenderBlocksRequestMessage extends SimulatorMessage {
        type: "renderblocks";
        id: string;
        code?: string;
        options?: {
            packageId?: string;
            package?: string;
            snippetMode?: boolean;
        };
    }
    interface RenderBlocksResponseMessage extends SimulatorMessage {
        source: "makecode";
        type: "renderblocks";
        id: string;
        svg?: string;
        width?: number;
        height?: number;
        css?: string;
        uri?: string;
        error?: string;
    }
    interface SetActivePlayerMessage extends SimulatorMessage {
        type: "setactiveplayer";
        playerNumber: 1 | 2 | 3 | 4 | undefined;
    }
    interface SetSimThemeMessage extends SimulatorMessage {
        type: "setsimthemecolor";
        part: "background-color" | "button-stroke" | "text-color" | "button-fill" | "dpad-fill";
        color: string;
    }
    interface SetMuteButtonStateMessage extends SimulatorMessage {
        type: "setmutebuttonstate";
        state: "muted" | "unmuted" | "disabled";
    }
    namespace multiplayer {
        type MessageBase = {
            type: "multiplayer";
            origin?: "server" | "client";
            broadcast?: boolean;
        };
        export enum IconType {
            Player = 0,
            Reaction = 1
        }
        export type ImageMessage = MessageBase & {
            content: "Image";
            image?: pxsim.RefBuffer;
            palette: Uint8Array;
        };
        export type InputMessage = MessageBase & {
            content: "Button";
            button: number;
            clientNumber: number;
            state: "Pressed" | "Released" | "Held";
        };
        export type AudioMessage = MessageBase & {
            content: "Audio";
            instruction: "playinstructions" | "muteallchannels";
            soundbuf?: Uint8Array;
        };
        export type IconMessage = MessageBase & {
            content: "Icon";
            icon?: pxsim.RefBuffer;
            slot: number;
            iconType: IconType;
            palette: Uint8Array;
        };
        export type ConnectionMessage = MessageBase & {
            content: "Connection";
            slot: number;
            connected: boolean;
        };
        export type Message = ImageMessage | AudioMessage | InputMessage | IconMessage | ConnectionMessage;
        export {};
    }
    function print(delay?: number): void;
    namespace Embed {
        let frameid: string;
        function start(): void;
        function stop(): void;
        function run(msg: SimulatorRunMessage): void;
    }
    /**
     * Log an event to the parent editor (allowSimTelemetry must be enabled in target)
     * @param id The id of the event
     * @param data Any custom values associated with this event
     */
    function tickEvent(id: string, data?: Map<string | number>): void;
    /**
     * Log an error to the parent editor (allowSimTelemetry must be enabled in target)
     * @param cat The category of the error
     * @param msg The error message
     * @param data Any custom values associated with this event
     */
    function reportError(cat: string, msg: string, data?: Map<string>): void;
    function reload(): void;
}
declare namespace pxsim.instructions {
    interface RenderPartsOptions {
        name: string;
        boardDef: BoardDefinition;
        parts: string[];
        partDefinitions: Map<PartDefinition>;
        fnArgs: any;
        configData: pxsim.ConfigData;
        print?: boolean;
    }
    function renderParts(container: HTMLElement, options: RenderPartsOptions): void;
    function renderInstructions(msg: SimulatorInstructionsMessage): void;
}
declare namespace pxsim {
    let quiet: boolean;
    function check(cond: boolean, msg?: string): void;
    let title: string;
    function getConfig(id: number): number;
    function getConfigKey(id: string): number;
    function getAllConfigKeys(): string[];
    function setConfigKey(key: string, id: number): void;
    function setConfig(id: number, val: number): void;
    function setConfigData(cfg_: Map<number>, cfgKey_: Map<number>): void;
    interface ConfigData {
        cfg: Map<number>;
        cfgKey: Map<number>;
    }
    function getConfigData(): ConfigData;
    function setTitle(t: string): void;
    class RefObject {
        id: number;
        constructor();
        destroy(): void;
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        gcIsStatic(): boolean;
        print(): void;
        toDebugString(): string;
        static toAny(o: any): any;
        static fromAny(o: any): any;
        static toDebugString(o: any): string;
    }
    class FnWrapper {
        func: LabelFn;
        caps: any[];
        args: any[];
        constructor(func: LabelFn, caps: any[], args: any[]);
    }
    interface VTable {
        name: string;
        methods: LabelFn[];
        numFields: number;
        toStringMethod?: LabelFn;
        classNo: number;
        lastSubtypeNo: number;
        iface?: Map<any>;
        maxBgInstances?: number;
    }
    class RefRecord extends RefObject {
        fields: any;
        vtable: VTable;
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        destroy(): void;
        print(): void;
        toDebugString(): string;
        toAny(): any;
        static fromAny(o: any): RefRecord;
    }
    class RefAction extends RefObject {
        fields: any[];
        len: number;
        func: LabelFn;
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        isRef(idx: number): boolean;
        ldclo(n: number): any;
        destroy(): void;
        print(): void;
    }
    namespace pxtcore {
        function seedAddRandom(num: number): void;
        function mkAction(len: number, fn: LabelFn): RefAction;
        function runAction(a: RefAction, args: any[]): void;
        function dumpPerfCounters(): void;
    }
    class RefRefLocal extends RefObject {
        v: any;
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        destroy(): void;
        print(): void;
    }
    interface MapEntry {
        key: string;
        val: any;
    }
    class RefMap extends RefObject {
        vtable: VTable;
        data: MapEntry[];
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        findIdx(key: string): number;
        destroy(): void;
        print(): void;
        toDebugString(): string;
        toAny(): any;
        static fromAny(o: any): RefMap;
    }
    function dumpLivePointers(): void;
    namespace numops {
        function toString(v: any): any;
        function toBoolDecr(v: any): boolean;
        function toBool(v: any): boolean;
    }
    namespace langsupp {
        function toInt(v: number): number;
        function toFloat(v: number): number;
        function ignore(v: any): any;
    }
    namespace pxtcore {
        function ptrOfLiteral(v: any): any;
        function debugMemLeaks(): void;
        function templateHash(): number;
        function programHash(): number;
        function programName(): string;
        function programSize(): number;
        function afterProgramPage(): number;
        function getConfig(key: number, defl: number): number;
        function toInt(n: number): number;
        function toUInt(n: number): number;
        function toDouble(n: number): number;
        function toFloat(n: number): number;
        function fromInt(n: number): number;
        function fromUInt(n: number): number;
        function fromDouble(n: number): number;
        function fromFloat(n: number): number;
        function fromBool(n: any): boolean;
    }
    namespace pxtrt {
        function toInt8(v: number): number;
        function toInt16(v: number): number;
        function toInt32(v: number): number;
        function toUInt32(v: number): number;
        function toUInt8(v: number): number;
        function toUInt16(v: number): number;
        function nullFix(v: any): any;
        function nullCheck(v: any): void;
        function panic(code: number): void;
        function stringToBool(s: string): 0 | 1;
        function ptrToBool(v: any): 0 | 1;
        function emptyToNull(s: string): any;
        function ldlocRef(r: RefRefLocal): any;
        function stlocRef(r: RefRefLocal, v: any): void;
        function mklocRef(): RefRefLocal;
        function stclo(a: RefAction, idx: number, v: any): RefAction;
        function runtimeWarning(msg: string): void;
        function mkMap(): RefMap;
        let mapKeyNames: string[];
        function mapGet(map: RefMap, key: number): any;
        function mapSet(map: RefMap, key: number, val: any): void;
        function mapGetByString(map: RefMap, key: string): any;
        function mapDeleteByString(map: RefMap, key: string): boolean;
        const mapSetGeneric: typeof mapSetByString;
        const mapGetGeneric: typeof mapGetByString;
        function mapSetByString(map: RefMap, key: string, val: any): void;
        function keysOf(v: RefMap): RefCollection;
        let getGlobalsPtr: any;
        let lookupMapKey: any;
    }
    namespace pxtcore {
        function mkClassInstance(vtable: VTable): RefRecord;
        function switch_eq(a: any, b: any): boolean;
        let getNumGlobals: any;
        let RefRecord_destroy: any;
        let RefRecord_print: any;
        let anyPrint: any;
        let dumpDmesg: any;
        let getVTable: any;
        let valType: any;
        let lookupPin: any;
        let deleteRefObject: any;
        let popThreadContext: any;
        let pushThreadContext: any;
        let failedCast: any;
        let missingProperty: any;
        let string_vt: any;
        let buffer_vt: any;
        let number_vt: any;
        let RefAction_vtable: any;
        let RefRecord_scan: any;
        let RefRecord_gcsize: any;
        let startPerfCounter: any;
        let stopPerfCounter: any;
        let string_inline_ascii_vt: any;
        let string_inline_utf8_vt: any;
        let string_cons_vt: any;
        let string_skiplist16_vt: any;
        let string_skiplist16_packed_vt: any;
        function typeOf(obj: any): "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
    }
    let __aeabi_dadd: any;
    let __aeabi_dcmplt: any;
    let __aeabi_dcmpgt: any;
    let __aeabi_dsub: any;
    let __aeabi_ddiv: any;
    let __aeabi_dmul: any;
    namespace thread {
        let panic: typeof pxtrt.panic;
        function pause(ms: number): void;
        function runInBackground(a: RefAction): void;
        function forever(a: RefAction): void;
        function typeCheck(a: RefAction): void;
    }
}
declare namespace pxsim {
    class RefCollection extends RefObject {
        private data;
        constructor();
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        toArray(): any[];
        toAny(): any[];
        static fromAny(arr: any[], deep?: boolean): RefCollection;
        toDebugString(): string;
        destroy(): void;
        isValidIndex(x: number): boolean;
        push(x: any): void;
        pop(): any;
        getLength(): number;
        setLength(x: number): void;
        getAt(x: number): any;
        setAt(x: number, y: any): void;
        insertAt(x: number, y: number): void;
        removeAt(x: number): any;
        indexOf(x: number, start: number): number;
        print(): void;
    }
    namespace Array_ {
        function mk(): RefCollection;
        function isArray(c: any): boolean;
        function length(c: RefCollection): number;
        function setLength(c: RefCollection, x: number): void;
        function push(c: RefCollection, x: any): void;
        function pop(c: RefCollection, x: any): any;
        function getAt(c: RefCollection, x: number): any;
        function removeAt(c: RefCollection, x: number): any;
        function insertAt(c: RefCollection, x: number, y: number): void;
        function setAt(c: RefCollection, x: number, y: any): void;
        function indexOf(c: RefCollection, x: any, start: number): number;
        function removeElement(c: RefCollection, x: any): 0 | 1;
        function typeCheck(c: RefCollection): void;
    }
    namespace Math_ {
        const imul: (x: number, y: number) => number;
        function idiv(x: number, y: number): number;
        function round(n: number): number;
        function roundWithPrecision(x: number, digits: number): number;
        function ceil(n: number): number;
        function floor(n: number): number;
        function sqrt(n: number): number;
        function pow(x: number, y: number): number;
        function clz32(n: number): number;
        function log(n: number): number;
        function log10(n: number): number;
        function log2(n: number): number;
        function exp(n: number): number;
        function sin(n: number): number;
        function sinh(n: number): number;
        function cos(n: number): number;
        function cosh(n: number): number;
        function tan(n: number): number;
        function tanh(n: number): number;
        function asin(n: number): number;
        function asinh(n: number): number;
        function acos(n: number): number;
        function acosh(n: number): number;
        function atan(n: number): number;
        function atanh(x: number): number;
        function atan2(y: number, x: number): number;
        function trunc(x: number): number;
        function random(): number;
        function randomRange(min: number, max: number): number;
    }
    namespace Number_ {
        function lt(x: number, y: number): boolean;
        function le(x: number, y: number): boolean;
        function neq(x: number, y: number): boolean;
        function eq(x: number, y: number): boolean;
        function eqDecr(x: number, y: number): boolean;
        function gt(x: number, y: number): boolean;
        function ge(x: number, y: number): boolean;
        function div(x: number, y: number): number;
        function mod(x: number, y: number): number;
        function bnot(x: number): number;
        function toString(x: number): string;
    }
    namespace thumb {
        function adds(x: number, y: number): number;
        function subs(x: number, y: number): number;
        function divs(x: number, y: number): number;
        function muls(x: number, y: number): number;
        function ands(x: number, y: number): number;
        function orrs(x: number, y: number): number;
        function eors(x: number, y: number): number;
        function lsls(x: number, y: number): number;
        function lsrs(x: number, y: number): number;
        function asrs(x: number, y: number): number;
        function bnot(x: number): number;
        function ignore(v: any): any;
    }
    namespace avr {
        function adds(x: number, y: number): number;
        function subs(x: number, y: number): number;
        function divs(x: number, y: number): number;
        function muls(x: number, y: number): number;
        function ands(x: number, y: number): number;
        function orrs(x: number, y: number): number;
        function eors(x: number, y: number): number;
        function lsls(x: number, y: number): number;
        function lsrs(x: number, y: number): number;
        function asrs(x: number, y: number): number;
        function bnot(x: number): number;
        function ignore(v: any): any;
    }
    namespace String_ {
        function stringConv(v: any): void;
        function mkEmpty(): string;
        function fromCharCode(code: number): string;
        function toNumber(s: string): number;
        function concat(a: string, b: string): string;
        function substring(s: string, i: number, j: number): string;
        function equals(s1: string, s2: string): boolean;
        function compare(s1: string, s2: string): 0 | 1 | -1;
        function compareDecr(s1: string, s2: string): 0 | 1 | -1;
        function length(s: string): number;
        function substr(s: string, start: number, length?: number): string;
        function charAt(s: string, i: number): string;
        function charCodeAt(s: string, i: number): number;
        function indexOf(s: string, searchValue: string, start?: number): number;
        function lastIndexOf(s: string, searchValue: string, start?: number): number;
        function includes(s: string, searchValue: string, start?: number): boolean;
        function typeCheck(s: string): void;
    }
    namespace Boolean_ {
        function toString(v: boolean): "true" | "false";
        function bang(v: boolean): boolean;
    }
    class RefBuffer extends RefObject {
        data: Uint8Array;
        isStatic: boolean;
        constructor(data: Uint8Array);
        scan(mark: (path: string, v: any) => void): void;
        gcKey(): string;
        gcSize(): number;
        gcIsStatic(): boolean;
        print(): void;
        toDebugString(): string;
    }
    namespace BufferMethods {
        enum NumberFormat {
            Int8LE = 1,
            UInt8LE = 2,
            Int16LE = 3,
            UInt16LE = 4,
            Int32LE = 5,
            Int8BE = 6,
            UInt8BE = 7,
            Int16BE = 8,
            UInt16BE = 9,
            Int32BE = 10,
            UInt32LE = 11,
            UInt32BE = 12,
            Float32LE = 13,
            Float64LE = 14,
            Float32BE = 15,
            Float64BE = 16
        }
        function fmtInfo(fmt: NumberFormat): {
            size: number;
            signed: boolean;
            swap: boolean;
            isFloat: boolean;
        };
        function getNumber(buf: RefBuffer, fmt: NumberFormat, offset: number): number;
        function setNumber(buf: RefBuffer, fmt: NumberFormat, offset: number, r: number): void;
        function createBuffer(size: number): RefBuffer;
        function createBufferFromHex(hex: string): RefBuffer;
        function isReadOnly(buf: RefBuffer): boolean;
        function getBytes(buf: RefBuffer): Uint8Array;
        function getUint8(buf: RefBuffer, off: number): number;
        function getByte(buf: RefBuffer, off: number): number;
        function setUint8(buf: RefBuffer, off: number, v: number): void;
        function setByte(buf: RefBuffer, off: number, v: number): void;
        function length(buf: RefBuffer): number;
        function fill(buf: RefBuffer, value: number, offset?: number, length?: number): void;
        function slice(buf: RefBuffer, offset: number, length: number): RefBuffer;
        function toHex(buf: RefBuffer): string;
        function toString(buf: RefBuffer): string;
        function shift(buf: RefBuffer, offset: number, start: number, len: number): void;
        function rotate(buf: RefBuffer, offset: number, start: number, len: number): void;
        function write(buf: RefBuffer, dstOffset: number, src: RefBuffer, srcOffset?: number, length?: number): void;
        function typeCheck(buf: RefBuffer): void;
    }
}
declare namespace pxsim.control {
    function createBufferFromUTF8(str: string): RefBuffer;
}
declare namespace pxsim.localization {
    function setLocalizedStrings(strs: Map<string>): void;
    function lf(s: string, ...args: any[]): string;
    function fmt_va(f: string, args: any[]): string;
    function htmlEscape(_input: string): string;
    function jsStringQuote(s: string): string;
}
declare namespace pxsim {
    interface Logger {
        info(...args: any[]): void;
        log(...args: any[]): void;
        debug(...args: any[]): void;
        error(...args: any[]): void;
        warn(...args: any[]): void;
        setLogLevel(level: LogLevel): void;
        getLogLevel(): LogLevel;
    }
    enum LogLevel {
        Debug = 0,
        Info = 1,
        Log = 1,
        Warning = 2,
        Error = 3
    }
    class ConsoleLogger implements Logger {
        protected logLevel: LogLevel;
        constructor();
        setLogLevel(level: LogLevel): void;
        getLogLevel(): LogLevel;
        info(...args: any[]): void;
        log(...args: any[]): void;
        debug(...args: any[]): void;
        error(...args: any[]): void;
        warn(...args: any[]): void;
        protected shouldLog(level: LogLevel): boolean;
    }
    function info(...args: any[]): void;
    function log(...args: any[]): void;
    function debug(...args: any[]): void;
    function error(...args: any[]): void;
    function warn(...args: any[]): void;
    function setLogger(impl: pxsim.Logger): void;
    function setLogLevel(level: pxsim.LogLevel): void;
}
declare namespace pxsim {
    export namespace U {
        function containsClass(el: SVGElement | HTMLElement, classes: string): boolean;
        function addClass(el: SVGElement | HTMLElement, classes: string): void;
        function removeClass(el: SVGElement | HTMLElement, classes: string): void;
        function remove(element: Element): void;
        function removeChildren(element: Element): void;
        function clear(element: Element): void;
        function assert(cond: boolean, msg?: string): void;
        function repeatMap<T>(n: number, fn: (index: number) => T): T[];
        function userError(msg: string): Error;
        function now(): number;
        function perfNowUs(): number;
        function nextTick(f: () => void): void;
        function delay<T>(duration: number, value: T): Promise<T>;
        function delay(duration: number): Promise<void>;
        function throttle(func: (...args: any[]) => any, wait: number, immediate?: boolean): any;
        function promiseMapAll<T, V>(values: T[], mapper: (obj: T) => Promise<V>): Promise<V[]>;
        function promiseMapAllSeries<T, V>(values: T[], mapper: (obj: T) => Promise<V>): Promise<V[]>;
        function promisePoolAsync<T, V>(maxConcurrent: number, inputValues: T[], handler: (input: T) => Promise<V>): Promise<V[]>;
        function promiseTimeout<T>(ms: number, promise: T | Promise<T>, msg?: string): Promise<T>;
        function stringToUint8Array(input: string): Uint8Array;
        function uint8ArrayToString(input: ArrayLike<number>): string;
        function fromUTF8(binstr: string): string;
        function toUTF8(str: string, cesu8?: boolean): string;
        function toUTF8Array(s: string): Uint8Array;
        function fromUTF8Array(s: Uint8Array): string;
        function isPxtElectron(): boolean;
        function isIpcRenderer(): boolean;
        function isElectron(): boolean;
        function testLocalhost(url: string): boolean;
        function isLocalHost(): boolean;
        function isLocalHostDev(): boolean;
        function unique<T>(arr: T[], f: (t: T) => string): T[];
        function sanitizeCssName(name: string): string;
    }
    export interface Map<T> {
        [index: string]: T;
    }
    export type LabelFn = (s: StackFrame) => StackFrame;
    export type ResumeFn = (v?: any) => void;
    export interface StackFrame {
        fn: LabelFn;
        pc: number;
        overwrittenPC?: boolean;
        depth: number;
        r0?: any;
        parent: StackFrame;
        retval?: any;
        lambdaArgs?: any[];
        caps?: any[];
        lastBrkId?: number;
        callLocIdx?: number;
        arg0?: any;
        stage2Call?: boolean;
        tryFrame?: TryFrame;
        thrownValue?: any;
        hasThrownValue?: boolean;
        threadId?: number;
    }
    export interface TryFrame {
        parent?: TryFrame;
        handlerPC: number;
        handlerFrame: StackFrame;
    }
    export class BreakLoopException {
    }
    export namespace pxtcore {
        function beginTry(lbl: number): void;
        function endTry(): void;
        function throwValue(v: any): void;
        function getThrownValue(): any;
        function endFinally(): void;
    }
    export let runtime: Runtime;
    export function getResume(): ResumeFn;
    export type MessageListener = (msg: SimulatorMessage) => void;
    export class BaseBoard {
        id: string;
        readonly bus: pxsim.EventBus;
        runOptions: SimulatorRunMessage;
        private readonly messageListeners;
        constructor();
        updateView(): void;
        receiveMessage(msg: SimulatorMessage): void;
        private dispatchMessage;
        addMessageListener(listener: MessageListener): void;
        get storedState(): Map<any>;
        initAsync(msg: SimulatorRunMessage): Promise<void>;
        setStoredState(k: string, value: any): void;
        onDebuggerResume(): void;
        screenshotAsync(width?: number): Promise<ImageData>;
        kill(): void;
        protected serialOutBuffer: string;
        private messages;
        private serialTimeout;
        private lastSerialTime;
        writeSerial(s: string): void;
        private debouncedPostAll;
    }
    export class CoreBoard extends BaseBoard {
        updateSubscribers: (() => void)[];
        builtinParts: Map<any>;
        builtinVisuals: Map<() => visuals.IBoardPart<any>>;
        builtinPartVisuals: Map<(xy: visuals.Coord) => visuals.SVGElAndSize>;
        constructor();
        kill(): void;
    }
    export interface EventBusBoard {
        bus: EventBus;
    }
    export function initBareRuntime(): void;
    export type EventValueToActionArgs = (value: EventIDType) => any[];
    export type EventIDType = number | string;
    class EventHandler {
        handler: RefAction;
        flags: number;
        private busy;
        constructor(handler: RefAction, flags: number);
        runAsync(eventValue: EventIDType, runtime: Runtime, valueToArgs?: EventValueToActionArgs): Promise<void>;
        private runFiberAsync;
    }
    export class EventQueue {
        runtime: Runtime;
        private valueToArgs?;
        max: number;
        events: EventIDType[];
        private awaiters;
        private lock;
        private _handlers;
        private _addRemoveLog;
        constructor(runtime: Runtime, valueToArgs?: EventValueToActionArgs);
        push(e: EventIDType, notifyOne: boolean): Promise<void>;
        private poke;
        get handlers(): EventHandler[];
        setHandler(a: RefAction, flags?: number): void;
        addHandler(a: RefAction, flags?: number): void;
        removeHandler(a: RefAction): void;
        addAwaiter(awaiter: (v?: any) => void): void;
    }
    export let initCurrentRuntime: (msg: SimulatorRunMessage) => void;
    export let handleCustomMessage: (message: pxsim.SimulatorCustomMessage) => void;
    export function syntheticRefAction(f: (s: StackFrame) => any): RefAction;
    export class TimeoutScheduled {
        id: any;
        fn: Function;
        totalRuntime: number;
        timestampCall: number;
        constructor(id: any, fn: Function, totalRuntime: number, timestampCall: number);
    }
    export class PausedTimeout {
        fn: Function;
        timeRemaining: number;
        constructor(fn: Function, timeRemaining: number);
    }
    export function mkVTable(src: VTable): VTable;
    export function mkMapVTable(): VTable;
    export function functionName(fn: LabelFn): string;
    export class Runtime {
        board: BaseBoard;
        numGlobals: number;
        errorHandler: (e: any) => void;
        postError: (e: any) => void;
        stateChanged: () => void;
        dead: boolean;
        running: boolean;
        idleTimer: any;
        recording: boolean;
        recordingTimer: any;
        recordingLastImageData: ImageData;
        recordingWidth: number;
        startTime: number;
        startTimeUs: number;
        pausedTime: number;
        lastPauseTimestamp: number;
        id: string;
        globals: any;
        environmentGlobals: any;
        currFrame: StackFrame;
        otherFrames: StackFrame[];
        entry: LabelFn;
        loopLock: Object;
        loopLockWaitList: (() => void)[];
        private heapSnapshots;
        timeoutsScheduled: TimeoutScheduled[];
        timeoutsPausedOnBreakpoint: PausedTimeout[];
        pausedOnBreakpoint: boolean;
        traceDisabled: boolean;
        perfCounters: PerfCounter[];
        perfOffset: number;
        perfElapsed: number;
        perfStack: number;
        lastInteractionTime: number;
        lastThumbnailTime: number;
        thumbnailRecordingIntervalRef: number;
        thumbnailFrames: ImageData[];
        refCountingDebug: boolean;
        private refObjId;
        overwriteResume: (retPC: number) => void;
        getResume: () => ResumeFn;
        run: (cb: ResumeFn) => void;
        setupTop: (cb: ResumeFn) => StackFrame;
        handleDebuggerMsg: (msg: DebuggerMessage) => void;
        registerLiveObject(object: RefObject): number;
        runningTime(): number;
        runningTimeUs(): number;
        runFiberAsync(a: RefAction, arg0?: any, arg1?: any, arg2?: any): Promise<any>;
        currTryFrame(): TryFrame;
        traceObjects(): string;
        getThreads(): StackFrame[];
        rootFrame(f: StackFrame): StackFrame;
        threadInfo(): string;
        static messagePosted: (data: SimulatorMessage) => void;
        static postMessage(data: SimulatorMessage): void;
        static postScreenshotAsync(opts?: SimulatorScreenshotMessage): Promise<void>;
        static requestToggleRecording(): void;
        restart(): void;
        kill(): void;
        updateDisplay(): void;
        startRecording(width?: number): void;
        stopRecording(): void;
        postFrame(): void;
        private numDisplayUpdates;
        queueDisplayUpdate(): void;
        maybeUpdateDisplay(): void;
        setRunning(r: boolean): void;
        dumpLivePointers(): void;
        constructor(msg: SimulatorRunMessage);
        setupPerfCounters(names: string[]): void;
        private perfStartRuntime;
        private perfStopRuntime;
        perfNow(): number;
        startPerfCounter(n: number): void;
        stopPerfCounter(n: number): void;
        startIdle(): void;
        stopIdle(): void;
        schedule(fn: Function, timeout: number): number;
        pauseScheduled(): void;
        resumeAllPausedScheduled(): void;
        cleanScheduledExpired(): void;
        registerUserInteraction(): void;
    }
    export function throwUserException(message: string): void;
    export function throwTypeError(message: string): void;
    export function throwFailedCastError(value: any, expectedType?: string): void;
    export function throwFailedPropertyAccessError(value: any, propertyName?: string): void;
    export function throwNullUndefinedAsObjectError(): void;
    export function setParentMuteState(state: "muted" | "unmuted" | "disabled"): void;
    export class PerfCounter {
        name: string;
        start: number;
        numstops: number;
        value: number;
        lastFew: Uint32Array;
        lastFewPtr: number;
        constructor(name: string);
    }
    export {};
}
declare namespace pxsim {
    interface SimulatorDriverOptions {
        restart?: () => void;
        revealElement?: (el: HTMLElement) => void;
        removeElement?: (el: HTMLElement, onComplete?: () => void) => void;
        unhideElement?: (el: HTMLElement) => void;
        onDebuggerWarning?: (wrn: DebuggerWarningMessage) => void;
        onDebuggerBreakpoint?: (brk: DebuggerBreakpointMessage) => void;
        onTraceMessage?: (msg: DebuggerBreakpointMessage) => void;
        onDebuggerResume?: () => void;
        onStateChanged?: (state: SimulatorState) => void;
        onSimulatorReady?: () => void;
        onSimulatorCommand?: (msg: pxsim.SimulatorCommandMessage) => void;
        onTopLevelCodeEnd?: () => void;
        onMuteButtonStateChange?: (state: "muted" | "unmuted" | "disabled") => void;
        simUrl?: string;
        stoppedClass?: string;
        invalidatedClass?: string;
        nestedEditorSim?: boolean;
        parentOrigin?: string;
        mpRole?: string;
        messageSimulators?: pxt.Map<{
            url: string;
            localHostUrl?: string;
            aspectRatio?: number;
            permanent?: boolean;
        }>;
        simulatorExtensions?: pxt.Map<{
            aspectRatio?: number;
            permanent?: boolean;
            index?: string;
            devUrl?: string;
            url?: string;
        }>;
        userLanguage?: string;
    }
    enum SimulatorState {
        Unloaded = 0,
        Stopped = 1,
        Pending = 2,
        Starting = 3,
        Running = 4,
        Paused = 5,
        Suspended = 6
    }
    enum SimulatorDebuggerCommand {
        StepInto = 0,
        StepOver = 1,
        StepOut = 2,
        Resume = 3,
        Pause = 4
    }
    interface SimulatorRunOptions {
        debug?: boolean;
        trace?: boolean;
        boardDefinition?: pxsim.BoardDefinition;
        parts?: string[];
        builtinParts?: string[];
        fnArgs?: any;
        aspectRatio?: number;
        partDefinitions?: pxsim.Map<PartDefinition>;
        mute?: boolean;
        highContrast?: boolean;
        light?: boolean;
        cdnUrl?: string;
        localizedStrings?: pxsim.Map<string>;
        refCountingDebug?: boolean;
        version?: string;
        clickTrigger?: boolean;
        breakOnStart?: boolean;
        storedState?: Map<any>;
        autoRun?: boolean;
        ipc?: boolean;
        dependencies?: Map<string>;
        single?: boolean;
        hideSimButtons?: boolean;
        autofocus?: boolean;
        queryParameters?: string;
        mpRole?: "server" | "client";
        activePlayer?: 1 | 2 | 3 | 4 | undefined;
        theme?: string | pxt.Map<string>;
    }
    interface HwDebugger {
        postMessage: (msg: pxsim.SimulatorMessage) => void;
    }
    class SimulatorDriver {
        container: HTMLElement;
        options: SimulatorDriverOptions;
        private themes;
        private runId;
        private nextFrameId;
        private frameCounter;
        private singleSimulator;
        private _currentRuntime;
        private listener;
        private traceInterval;
        private breakpointsSet;
        private _runOptions;
        state: SimulatorState;
        hwdbg: HwDebugger;
        private _dependentEditors;
        private _allowedOrigins;
        private debuggingFrame;
        private loanedSimulator;
        constructor(container: HTMLElement, options?: SimulatorDriverOptions);
        isDebug(): boolean;
        isTracing(): boolean;
        hasParts(): boolean;
        setDirty(): void;
        setPending(): void;
        focus(): void;
        registerDependentEditor(w: Window): void;
        private dependentEditors;
        private setStarting;
        setHwDebugger(hw: HwDebugger): void;
        handleHwDebuggerMsg(msg: pxsim.SimulatorMessage): void;
        setThemes(themes: string[]): void;
        startRecording(width?: number): void;
        stopRecording(): void;
        private setFrameState;
        private setState;
        private freeze;
        private simFrames;
        private getSimUrl;
        setSingleSimulator(): void;
        newJacdacSimulator: boolean;
        postMessage(msg: pxsim.SimulatorMessage, source?: Window, frameID?: string): void;
        protected deferredMessages: [HTMLIFrameElement, SimulatorMessage][];
        protected postDeferrableMessage(frame: HTMLIFrameElement, msg: SimulatorMessage): void;
        private postMessageCore;
        private setRunOptionQueryParams;
        private createFrame;
        preload(aspectRatio: number, clearRuntime?: boolean): void;
        stop(unload?: boolean, starting?: boolean): void;
        suspend(): void;
        private unload;
        mute(mute: boolean): void;
        stopSound(): void;
        isLoanedSimulator(el: HTMLElement): boolean;
        loanSimulator(): HTMLDivElement;
        unloanSimulator(): void;
        private loanedIFrame;
        private frameCleanupTimeout;
        private cancelFrameCleanup;
        private scheduleFrameCleanup;
        private applyAspectRatio;
        private applyAspectRatioToFrame;
        private cleanupFrames;
        hide(completeHandler?: () => void): void;
        unhide(): void;
        setRunOptions(opts?: SimulatorRunOptions): void;
        run(js: string, opts?: SimulatorRunOptions): void;
        restart(): void;
        areBreakpointsSet(): boolean;
        private start;
        private startFrame;
        private handleDeferredMessages;
        private handleMessage;
        private addEventListeners;
        private removeEventListeners;
        resume(c: SimulatorDebuggerCommand): void;
        setBreakpoints(breakPoints: number[]): void;
        setTraceInterval(intervalMs: number): void;
        variablesAsync(id: number, fields?: string[], includeAll?: boolean): Promise<VariablesMessage>;
        private handleSimulatorCommand;
        private debuggerSeq;
        private debuggerResolvers;
        private clearDebugger;
        private handleDebuggerMessage;
        private postDebuggerMessageAsync;
        private postDebuggerMessage;
        private nextId;
        private get stoppedClass();
        private get invalidatedClass();
    }
}
declare namespace pxsim {
    type BoardPin = string;
    interface BBLoc {
        type: "breadboard";
        row: string;
        col: string;
        xOffset?: number;
        yOffset?: number;
        style?: PinStyle;
    }
    interface BoardLoc {
        type: "dalboard";
        pin: BoardPin;
    }
    type Loc = BBLoc | BoardLoc;
    function mkRange(a: number, b: number): number[];
    class EventBus {
        private readonly runtime;
        private readonly board;
        private readonly valueToArgs?;
        private queues;
        private notifyID;
        private notifyOneID;
        private schedulerID;
        private idleEventID;
        private lastEventValue;
        private lastEventTimestampUs;
        private backgroundHandlerFlag;
        nextNotifyEvent: number;
        constructor(runtime: Runtime, board: BaseBoard, valueToArgs?: EventValueToActionArgs);
        private handleMessage;
        setBackgroundHandlerFlag(): void;
        setNotify(notifyID: number, notifyOneID: number): void;
        setIdle(schedulerID: number, idleEventID: number): void;
        private start;
        listen(id: EventIDType, evid: EventIDType, handler: RefAction, flags?: number): void;
        removeBackgroundHandler(handler: RefAction): void;
        private getQueues;
        queue(id: EventIDType, evid: EventIDType, value?: EventIDType): void;
        queueIdle(): void;
        wait(id: number | string, evid: number | string, cb: (value?: any) => void): void;
        getLastEventValue(): string | number;
        getLastEventTime(): number;
    }
    interface AnimationOptions {
        interval: number;
        frame: () => boolean;
        whenDone?: (cancelled: boolean) => void;
        setTimeoutHandle?: any;
    }
    class AnimationQueue {
        private runtime;
        private queue;
        private process;
        constructor(runtime: Runtime);
        cancelAll(): void;
        cancelCurrent(): void;
        enqueue(anim: AnimationOptions): void;
        executeAsync(anim: AnimationOptions): Promise<boolean>;
    }
    namespace AudioContextManager {
        function isAudioElementActive(): boolean;
        let soundEventCallback: (ev: "playinstructions" | "muteallchannels", data?: Uint8Array) => void;
        function mute(mute: boolean): void;
        function isMuted(): boolean;
        function stopAll(): void;
        function stop(): void;
        function onStopAll(handler: () => void): void;
        function frequency(): number;
        function muteAllChannels(): void;
        function queuePlayInstructions(when: number, b: RefBuffer): void;
        function tone(frequency: number, gain: number): void;
        function setCurrentToneGain(gain: number): void;
        function playBufferAsync(buf: RefBuffer): Promise<void>;
        function playPCMBufferStreamAsync(pull: () => Float32Array, sampleRate: number, volume?: number, isCancelled?: () => boolean): Promise<void>;
        function playInstructionsAsync(instructions: Uint8Array, isCancelled?: () => boolean, onPull?: (freq: number, volume: number) => void): Promise<void>;
        function sendMidiMessage(buf: RefBuffer): void;
        interface PlaySampleResult {
            promise: Promise<void>;
            cancel: () => void;
        }
        function startSamplePlayback(sample: RefBuffer, format: BufferMethods.NumberFormat, sampleRange: number, sampleRate: number, gain: number): PlaySampleResult;
        function createAudioSourceNode(uri: string, clippingThreshold: number, volume: number): HTMLAudioElement;
    }
    interface IPointerEvents {
        up: string;
        down: string[];
        move: string;
        enter: string;
        leave: string;
    }
    function isTouchEnabled(): boolean;
    function hasPointerEvents(): boolean;
    const pointerEvents: IPointerEvents;
}
declare namespace pxsim.visuals {
    interface IBoardPart<T> {
        style: string;
        element: SVGElement;
        overElement?: SVGElement;
        defs: SVGElement[];
        init(bus: EventBus, state: T, svgEl: SVGSVGElement, otherParams: Map<string>): void;
        moveToCoord(xy: visuals.Coord): void;
        updateState(): void;
        updateTheme(): void;
    }
    function translateEl(el: SVGElement, xy: [number, number]): void;
    interface ComposeOpts {
        el1: SVGAndSize<SVGSVGElement>;
        scaleUnit1: number;
        el2: SVGAndSize<SVGSVGElement>;
        scaleUnit2: number;
        margin: [number, number, number, number];
        middleMargin: number;
        maxWidth?: string;
        maxHeight?: string;
    }
    interface ComposeResult {
        host: SVGSVGElement;
        scaleUnit: number;
        under: SVGGElement;
        over: SVGGElement;
        edges: number[];
        toHostCoord1: (xy: Coord) => Coord;
        toHostCoord2: (xy: Coord) => Coord;
    }
    function composeSVG(opts: ComposeOpts): ComposeResult;
    function mkScaleFn(originUnit: number, targetUnit: number): (n: number) => number;
    interface MkImageOpts {
        image: string;
        width: number;
        height: number;
        imageUnitDist: number;
        targetUnitDist: number;
    }
    function mkImageSVG(opts: MkImageOpts): SVGAndSize<SVGImageElement>;
    type Coord = [number, number];
    function findDistSqrd(a: Coord, b: Coord): number;
    function findClosestCoordIdx(a: Coord, bs: Coord[]): number;
    function mkTxt(cx: number, cy: number, size: number, rot: number, txt: string, txtXOffFactor?: number, txtYOffFactor?: number): SVGTextElement;
    type WireColor = "black" | "white" | "gray" | "purple" | "blue" | "green" | "yellow" | "orange" | "red" | "brown" | "pink";
    const GPIO_WIRE_COLORS: string[];
    const WIRE_COLOR_MAP: Map<string>;
    function mapWireColor(clr: WireColor | string): string;
    interface SVGAndSize<T extends SVGElement> {
        el: T;
        y: number;
        x: number;
        w: number;
        h: number;
    }
    type SVGElAndSize = SVGAndSize<SVGElement>;
    const PIN_DIST = 15;
    interface BoardView {
        getView(): SVGAndSize<SVGSVGElement>;
        getCoord(pinNm: string): Coord;
        getPinDist(): number;
        highlightPin(pinNm: string): void;
        removeEventListeners?(): void;
    }
    function rgbToHsl(rgb: [number, number, number]): [number, number, number];
}
declare namespace pxsim.svg {
    function parseString(xml: string): SVGSVGElement;
    function toDataUri(xml: string): string;
    function cursorPoint(pt: SVGPoint, svg: SVGSVGElement, evt: MouseEvent): SVGPoint;
    function rotateElement(el: SVGElement, originX: number, originY: number, degrees: number): void;
    function hydrate(el: SVGElement, props: any): void;
    function elt(name: string, props?: any): SVGElement;
    function child(parent: Element, name: string, props?: any): SVGElement;
    function mkPath(cls: string, data: string, title?: string): SVGPathElement;
    function path(parent: Element, cls: string, data: string, title?: string): SVGPathElement;
    function fill(el: SVGElement, c: string): void;
    function filter(el: SVGElement, c: string): void;
    function fills(els: SVGElement[], c: string): void;
    function isTouchEnabled(): boolean;
    function onClick(el: Element, click: (ev: MouseEvent) => void): void;
    function buttonEvents(el: Element, move?: (ev: MouseEvent) => void, start?: (ev: MouseEvent) => void, stop?: (ev: MouseEvent) => void, keydown?: (ev: KeyboardEvent) => void): void;
    function mkLinearGradient(id: string, horizontal?: boolean): SVGLinearGradientElement;
    function linearGradient(defs: SVGDefsElement, id: string, horizontal?: boolean): SVGLinearGradientElement;
    function setGradientColors(lg: SVGLinearGradientElement, start: string, end: string): void;
    function setGradientValue(lg: SVGLinearGradientElement, percent: string): void;
    function animate(el: SVGElement, cls: string): void;
    function mkTitle(txt: string): SVGTitleElement;
    function title(el: SVGElement, txt: string): SVGTitleElement;
    function toHtmlColor(c: number): string;
}
declare namespace pxsim.music {
    interface MetronomeMessage {
        type: "start" | "stop" | "set-interval";
        interval?: number;
    }
    export class Metronome {
        protected metronomeLoadPromise: Promise<Worker>;
        protected metronomeWorker: Worker;
        protected tickListeners: (() => void)[];
        protected currentInterval: number;
        initAsync(): Worker | Promise<Worker>;
        stop(): void;
        setInterval(interval: number): void;
        start(interval: number): void;
        addTickListener(listener: () => void): void;
        removeTickListener(listener: () => void): void;
        interval(): number;
        dispose(): void;
        protected onTick: () => void;
        protected postMessage(message: MetronomeMessage): void;
    }
    export {};
}
declare namespace pxsim.codal.music {
    interface Progression {
        interval: number[];
        length: number;
    }
}
declare namespace pxsim.codal.music.MusicalIntervals {
    const chromaticInterval: number[];
    const majorScaleInterval: number[];
    const minorScaleInterval: number[];
    const pentatonicScaleInterval: number[];
    const majorTriadInterval: number[];
    const minorTriadInterval: number[];
    const diminishedInterval: number[];
    const wholeToneInterval: number[];
}
declare namespace pxsim.codal.music.MusicalProgressions {
    const chromatic: Progression;
    const majorScale: Progression;
    const minorScale: Progression;
    const pentatonicScale: Progression;
    const majorTriad: Progression;
    const minorTriad: Progression;
    const diminished: Progression;
    const wholeTone: Progression;
    /**
     * Determine the frequency of a given note in a given progressions
     *
     * @param root The root frequency of the progression
     * @param progression The Progression to use
     * @param offset The offset (interval) of the note to generate
     * @return The frequency of the note requested in Hz.
     */
    function calculateFrequencyFromProgression(root: number, progression: Progression, offset: number): number;
}
declare namespace pxsim.music {
    type SequencerState = "play" | "loop" | "stop";
    type SequencerEvent = "tick" | "play" | "stop" | "loop" | "state-change" | "looped";
    class Sequencer {
        protected metronome: Metronome;
        protected _currentTick: number;
        protected _state: SequencerState;
        protected currentlyPlaying: pxt.assets.music.Song;
        protected listeners: {
            [index: string]: (() => void)[];
        };
        protected shouldLoop: boolean;
        protected globalVolume: number;
        protected trackVolumes: number[];
        protected drumTrackVolumes: number[][];
        protected currentCancelToken: {
            cancelled: boolean;
        };
        constructor();
        initAsync(): Promise<void>;
        dispose(): void;
        state(): SequencerState;
        currentTick(): number;
        currentTime(): number;
        maxTick(): number;
        duration(): number;
        start(song: pxt.assets.music.Song, loop?: boolean): void;
        startFrom(song: pxt.assets.music.Song, loop?: boolean, tick?: number): void;
        stop(sustainCurrentSounds?: boolean): void;
        updateSong(song: pxt.assets.music.Song): void;
        setLooping(looping: boolean): void;
        addEventListener(event: SequencerEvent, listener: () => void): void;
        removeEventListener(event: SequencerEvent, listener: () => void): void;
        setVolume(volume: number): void;
        setTrackVolume(trackIndex: number, volume: number): void;
        setDrumTrackVolume(trackIndex: number, drumIndex: number, volume: number): void;
        protected getMelodicTrackVolume(trackIndex: number): number;
        protected getDrumTrackVolume(trackIndex: number, drumIndex: number): number;
        protected fireStateChange(): void;
        protected fireEvent(event: SequencerEvent): void;
        protected onTick: () => void;
    }
    function playNoteAsync(note: number, instrument: pxt.assets.music.Instrument, time: number, isCancelled?: () => boolean, volume?: number): Promise<void>;
    function playDrumAsync(drum: pxt.assets.music.DrumInstrument, isCancelled?: () => boolean, volume?: number): Promise<void>;
    function tickToMs(beatsPerMinute: number, ticksPerBeat: number, ticks: number): number;
}
declare namespace pxsim.music {
    function renderInstrument(instrument: pxt.assets.music.Instrument, noteFrequency: number, gateLength: number, volume: number): Uint8Array;
    function renderDrumInstrument(sound: pxt.assets.music.DrumInstrument, volume: number): Uint8Array;
    function decodeSong(buf: Uint8Array): pxt.assets.music.Song;
}
/**
 * Adapted from lancaster-university/codal-microbit-v2
 * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/SoundEmojiSynthesizer.cpp
 */
declare namespace pxsim.codal.music {
    const EMOJI_SYNTHESIZER_SAMPLE_RATE = 44100;
    const EMOJI_SYNTHESIZER_TONE_WIDTH_F = 1024;
    const EMOJI_SYNTHESIZER_TONE_WIDTH = 1024;
    const EMOJI_SYNTHESIZER_BUFFER_SIZE = 512;
    const EMOJI_SYNTHESIZER_TONE_EFFECT_PARAMETERS = 2;
    const EMOJI_SYNTHESIZER_TONE_EFFECTS = 3;
    const EMOJI_SYNTHESIZER_STATUS_ACTIVE = 1;
    const EMOJI_SYNTHESIZER_STATUS_OUTPUT_SILENCE_AS_EMPTY = 2;
    const EMOJI_SYNTHESIZER_STATUS_STOPPING = 4;
    class SoundEmojiSynthesizer {
        bufferSize: number;
        buffer: number[];
        sampleRate: number;
        sampleRange: number;
        samplesPerStep: number[];
        samplesToWrite: number;
        samplesWritten: number;
        orMask: number;
        frequency: number;
        volume: number;
        position: number;
        status: number;
        effectPointer: number;
        effectBuffer: SoundEffect[];
        get effect(): SoundEffect;
        constructor(id: number, sampleRate?: number);
        play(sound: SoundEffect[]): void;
        nextSoundEffect(): boolean;
        pull(): number[];
        determineSampleCount(playoutTime: number): number;
        totalDuration(): number;
    }
}
/**
 * Adapted from lancaster-university/codal-core
 * https://github.com/lancaster-university/codal-core/blob/master/source/streams/Synthesizer.cpp#L54
 */
declare namespace pxsim.codal.music.Synthesizer {
    function SineTone(arg: number[], position: number): number;
    function SawtoothTone(arg: number[], position: number): number;
    function TriangleTone(arg: number[], position: number): number;
    function NoiseTone(arg: number[], position: number): number;
    function SquareWaveTone(arg: number[], position: number): 0 | 1023;
}
/**
 * Adapted from lancaster-university/codal-microbit-v2
 * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/SoundSynthesizerEffects.cpp
 */
declare namespace pxsim.codal.music.SoundSynthesizerEffects {
    /**
     * Root Frequency Interpolation Effect Functions
     */
    function noInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function linearInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function logarithmicInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function curveInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function slowVibratoInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function warbleInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function vibratoInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function exponentialRisingInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function exponentialFallingInterpolation(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function appregrioAscending(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function appregrioDescending(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    /**
     * Frequency Delta effects
     */
    function frequencyVibratoEffect(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    function volumeVibratoEffect(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    /**
     * Volume Delta effects
     */
    /** Simple ADSR enveleope effect.
     * parameter[0]: Centre volume
     * parameter[1]: End volume
     * effect.volume: start volume
     */
    function adsrVolumeEffect(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
    /**
     * Simple volume ramp effect
     * parameter[0]: End volume
     * effect.volume: start volume
     */
    function volumeRampEffect(synth: SoundEmojiSynthesizer, context: ToneEffect): void;
}
declare namespace pxsim.codal.music {
    enum WaveShape {
        Sine = 0,
        Sawtooth = 1,
        Triangle = 2,
        Square = 3,
        Noise = 4
    }
    enum InterpolationEffect {
        None = 0,
        Linear = 1,
        Curve = 2,
        ExponentialRising = 5,
        ExponentialFalling = 6,
        ArpeggioRisingMajor = 8,
        ArpeggioRisingMinor = 10,
        ArpeggioRisingDiminished = 12,
        ArpeggioRisingChromatic = 14,
        ArpeggioRisingWholeTone = 16,
        ArpeggioFallingMajor = 9,
        ArpeggioFallingMinor = 11,
        ArpeggioFallingDiminished = 13,
        ArpeggioFallingChromatic = 15,
        ArpeggioFallingWholeTone = 17,
        Logarithmic = 18
    }
    enum Effect {
        None = 0,
        Vibrato = 1,
        Tremolo = 2,
        Warble = 3
    }
    class Sound {
        src: string;
        constructor();
        get wave(): WaveShape;
        set wave(value: WaveShape);
        get volume(): number;
        set volume(value: number);
        get frequency(): number;
        set frequency(value: number);
        get duration(): number;
        set duration(value: number);
        get shape(): InterpolationEffect;
        set shape(value: InterpolationEffect);
        get endFrequency(): number;
        set endFrequency(value: number);
        get endVolume(): number;
        set endVolume(value: number);
        get steps(): number;
        set steps(value: number);
        get fx(): Effect;
        set fx(value: Effect);
        get fxParam(): number;
        set fxParam(value: number);
        get fxnSteps(): number;
        set fxnSteps(value: number);
        get frequencyRandomness(): number;
        set frequencyRandomness(value: number);
        get endFrequencyRandomness(): number;
        set endFrequencyRandomness(value: number);
        get volumeRandomness(): number;
        set volumeRandomness(value: number);
        get endVolumeRandomness(): number;
        set endVolumeRandomness(value: number);
        get durationRandomness(): number;
        set durationRandomness(value: number);
        get fxParamRandomness(): number;
        set fxParamRandomness(value: number);
        get fxnStepsRandomness(): number;
        set fxnStepsRandomness(value: number);
        copy(): Sound;
        protected setValue(offset: number, value: number, length: number): void;
        protected getValue(offset: number, length: number): number;
    }
    function isSoundExpPlaying(): boolean;
    function __playSoundExpression(notes: string, waitTillDone: boolean, volume?: number): void;
    function clearSoundQueue(): void;
    function playSoundExpressionAsync(notes: string, isCancelled?: () => boolean, onPull?: (freq: number, volume: number) => void, volume?: number): Promise<void>;
    function __stopSoundExpressions(): void;
    interface TonePrint {
        tonePrint: (arg: number[], position: number) => number;
        parameter: number[];
    }
    interface ToneEffect {
        effect: (synth: SoundEmojiSynthesizer, context: ToneEffect) => void;
        step: number;
        steps: number;
        parameter: number[];
        parameter_p: Progression[];
    }
    interface SoundEffect {
        frequency: number;
        volume: number;
        duration: number;
        tone: TonePrint;
        effects: ToneEffect[];
    }
    function parseSoundExpression(soundChars: string, fx: SoundEffect): boolean;
}
declare namespace pxsim {
    class Button {
        id: number;
        constructor(id: number);
        pressed: boolean;
        virtual: boolean;
    }
    interface ButtonPairProps {
        ID_BUTTON_A: number;
        ID_BUTTON_B: number;
        ID_BUTTON_AB: number;
        BUTTON_EVT_UP: number;
        BUTTON_EVT_CLICK: number;
    }
    class ButtonPairState {
        props: ButtonPairProps;
        usesButtonAB: boolean;
        aBtn: Button;
        bBtn: Button;
        abBtn: Button;
        constructor(props: ButtonPairProps);
    }
}
declare namespace pxsim {
    class CompassState {
        usesHeading: boolean;
        heading: number;
    }
}
declare namespace pxsim {
    class FileSystemState {
        files: Map<string>;
        append(file: string, content: string): void;
        remove(file: string): void;
    }
}
declare namespace pxsim {
    class LightSensorState {
        usesLightLevel: boolean;
        lightLevel: number;
    }
}
declare namespace pxsim.visuals {
    interface BoardViewOptions {
        visual: string | BoardImageDefinition;
        boardDef: BoardDefinition;
        wireframe?: boolean;
        highContrast?: boolean;
        light?: boolean;
    }
    interface BoardHostOpts {
        state: CoreBoard;
        boardDef: BoardDefinition;
        partsList: string[];
        partDefs: Map<PartDefinition>;
        fnArgs: any;
        forceBreadboardLayout?: boolean;
        forceBreadboardRender?: boolean;
        maxWidth?: string;
        maxHeight?: string;
        wireframe?: boolean;
        highContrast?: boolean;
        light?: boolean;
    }
    let mkBoardView: (opts: BoardViewOptions) => BoardView;
    class BoardHost {
        private opts;
        private parts;
        private wireFactory;
        private breadboard;
        private fromBBCoord;
        private fromMBCoord;
        private boardView;
        private view;
        private partGroup;
        private partOverGroup;
        private style;
        private defs;
        private state;
        constructor(view: BoardView, opts: BoardHostOpts);
        highlightBoardPin(pinNm: string): void;
        removeEventListeners(): void;
        highlightBreadboardPin(rowCol: BBLoc): void;
        highlightWire(wire: Wire): void;
        getView(): SVGElement;
        screenshotAsync(width?: number): Promise<ImageData>;
        private updateState;
        private getBBCoord;
        private getPinCoord;
        getLocCoord(loc: Loc): Coord;
        getPinStyle(loc: Loc): PinStyle;
        addPart(partInst: PartInst): IBoardPart<any>;
        addWire(inst: WireInst): Wire;
        addAll(allocRes: AllocatorResult): void;
    }
}
declare namespace pxsim.visuals {
    const BREADBOARD_MID_ROWS = 10;
    const BREADBOARD_MID_COLS = 30;
    function getColumnName(colIdx: number): string;
    function getRowName(rowIdx: number): string;
    interface GridPin {
        el: SVGElement;
        hoverEl: SVGElement;
        cx: number;
        cy: number;
        row: string;
        col: string;
        group?: string;
    }
    interface GridOptions {
        xOffset?: number;
        yOffset?: number;
        rowCount: number;
        colCount: number;
        rowStartIdx?: number;
        colStartIdx?: number;
        pinDist: number;
        mkPin: () => SVGElAndSize;
        mkHoverPin: () => SVGElAndSize;
        getRowName: (rowIdx: number) => string;
        getColName: (colIdx: number) => string;
        getGroupName?: (rowIdx: number, colIdx: number) => string;
        rowIdxsWithGap?: number[];
        colIdxsWithGap?: number[];
    }
    interface GridResult {
        g: SVGGElement;
        allPins: GridPin[];
    }
    function mkGrid(opts: GridOptions): GridResult;
    interface GridLabel {
        el: SVGTextElement;
        hoverEl: SVGTextElement;
        txt: string;
        group?: string;
    }
    interface BreadboardOpts {
        wireframe?: boolean;
    }
    class Breadboard {
        bb: SVGSVGElement;
        private styleEl;
        private defs;
        private allPins;
        private allLabels;
        private allPowerBars;
        private rowColToPin;
        private rowColToLbls;
        constructor(opts: BreadboardOpts);
        hide(): void;
        updateLocation(x: number, y: number): void;
        getPin(row: string, col: string): GridPin;
        getCoord(rowCol: BBLoc): Coord;
        getPinDist(): number;
        private buildDom;
        getSVGAndSize(): SVGAndSize<SVGSVGElement>;
        highlightLoc(rowCol: BBLoc): void;
    }
}
declare namespace pxsim.visuals {
    const BOARD_SYTLE: string;
    interface GenericBoardProps {
        visualDef: BoardImageDefinition;
        boardDef: BoardDefinition;
        wireframe?: boolean;
    }
    class GenericBoardSvg implements BoardView {
        props: GenericBoardProps;
        private element;
        private style;
        private defs;
        private g;
        private background;
        private width;
        private height;
        private id;
        private allPins;
        private allLabels;
        private pinNmToLbl;
        private pinNmToPin;
        constructor(props: GenericBoardProps);
        private findPin;
        private findPinLabel;
        getCoord(pinNm: string): Coord;
        private mkGrayCover;
        getView(): SVGAndSize<SVGSVGElement>;
        getPinDist(): number;
        highlightPin(pinNm: string): void;
    }
}
declare namespace pxsim.visuals {
    function mkGenericPartSVG(partVisual: PartVisualDefinition): SVGAndSize<SVGImageElement>;
    class GenericPart implements IBoardPart<any> {
        style: string;
        element: SVGElement;
        defs: SVGElement[];
        constructor(partVisual: PartVisualDefinition);
        moveToCoord(xy: Coord): void;
        init(bus: EventBus, state: any, svgEl: SVGSVGElement): void;
        updateState(): void;
        updateTheme(): void;
    }
}
declare namespace pxsim.visuals {
    const WIRES_CSS: string;
    interface Wire {
        endG: SVGGElement;
        end1: SVGElement;
        end2: SVGElement;
        wires: SVGElement[];
    }
    enum WireEndStyle {
        BBJumper = 0,
        OpenJumper = 1,
        Croc = 2
    }
    interface WireOpts {
        color?: string;
        colorClass?: string;
        bendFactor?: number;
    }
    function mkWirePart(cp: [number, number], clr: string, croc?: boolean): visuals.SVGAndSize<SVGGElement>;
    class WireFactory {
        private underboard;
        private overboard;
        private boardEdges;
        private getLocCoord;
        private getPinStyle;
        styleEl: SVGStyleElement;
        constructor(underboard: SVGGElement, overboard: SVGGElement, boardEdges: number[], styleEl: SVGStyleElement, getLocCoord: (loc: Loc) => Coord, getPinStyle: (loc: Loc) => PinStyle);
        private indexOfMin;
        private closestEdgeIdx;
        private closestEdge;
        private nextWireId;
        private drawWire;
        private drawWireWithCrocs;
        checkWire(start: Loc, end: Loc): boolean;
        addWire(start: Loc, end: Loc, color: string): Wire;
    }
}
