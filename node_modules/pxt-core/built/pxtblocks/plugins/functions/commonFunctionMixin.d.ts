import * as Blockly from "blockly";
import { StringMap } from "./utils";
declare type CommonFunctionMixinType = typeof COMMON_FUNCTION_MIXIN;
export interface CommonFunctionMixin extends CommonFunctionMixinType {
    hasStatements_?: boolean;
    populateArgument_(arg: FunctionArgument, connectionMap: ConnectionMap | undefined, input: Blockly.Input): void;
    addFunctionLabel_(text: string): void;
    updateFunctionLabel_(text: string): void;
}
export declare type CommonFunctionBlock = Blockly.Block & CommonFunctionMixin;
export interface FunctionArgument {
    id: string;
    name: string;
    type: string;
}
export interface ConnectionMapEntry {
    shadow: Element | null;
    block: Blockly.Block | null;
}
export declare type ConnectionMap = StringMap<ConnectionMapEntry>;
export interface FunctionDefinitionExtraState {
    name: string;
    functionid: string;
    arguments: FunctionArgument[];
}
export declare const COMMON_FUNCTION_MIXIN: {
    name_: string;
    functionId_: string;
    arguments_: FunctionArgument[];
    mutationToDom: (this: CommonFunctionBlock) => Element | null;
    domToMutation: (this: CommonFunctionBlock, xmlElement: Element) => void;
    saveExtraState: (this: CommonFunctionBlock) => FunctionDefinitionExtraState | null;
    loadExtraState: (this: CommonFunctionBlock, state: FunctionDefinitionExtraState) => void;
    restoreSavedFunctionId: (this: CommonFunctionBlock, functionId_: string) => void;
    getName: (this: CommonFunctionBlock) => string;
    getFunctionId: (this: CommonFunctionBlock) => string;
    getArguments: (this: CommonFunctionBlock) => FunctionArgument[];
    removeValueInputs_: (this: CommonFunctionBlock) => void;
    createAllInputs_: (this: CommonFunctionBlock) => void;
    updateArgumentInputs_(this: CommonFunctionBlock): void;
    updateDisplay_: (this: CommonFunctionBlock) => void;
    setStatements_: (this: CommonFunctionBlock, hasStatements: boolean) => void;
    ensureIds_: (this: CommonFunctionBlock) => void;
};
export {};
