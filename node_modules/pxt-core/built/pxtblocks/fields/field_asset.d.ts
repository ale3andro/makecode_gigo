/// <reference path="../../pxtlib.d.ts" />
import * as Blockly from "blockly";
import { FieldBase } from "./field_base";
export interface FieldAssetEditorOptions {
    initWidth?: string;
    initHeight?: string;
    disableResize?: string;
}
interface ParsedFieldAssetEditorOptions {
    initWidth?: number;
    initHeight?: number;
    disableResize?: boolean;
    lightMode?: boolean;
}
export declare abstract class FieldAssetEditor<U extends FieldAssetEditorOptions, V extends ParsedFieldAssetEditorOptions> extends FieldBase<U> {
    protected asset: pxt.Asset;
    protected params: V;
    protected blocksInfo: pxtc.BlocksInfo;
    protected lightMode: boolean;
    protected undoRedoState: any;
    protected pendingEdit: boolean;
    protected isEmpty: boolean;
    protected qName?: string;
    isGreyBlock: boolean;
    constructor(text: string, params: any, validator?: Blockly.FieldValidator);
    protected abstract getAssetType(): pxt.AssetType;
    protected abstract createNewAsset(text?: string): pxt.Asset;
    protected abstract getValueText(): string;
    onInit(): void;
    onValueChanged(newValue: string): string;
    saveState(_doFullSerialization?: boolean): any;
    loadState(state: any): void;
    showEditor_(): void;
    getFieldDescription(): string;
    protected showEditorFullscreen(editorKind: string, params: any): void;
    protected showEditorInWidgetDiv(editorKind: string, params: any): void;
    protected onFieldEditorHide(fv: pxt.react.FieldEditorView<pxt.Asset>): void;
    render_(): void;
    getDisplayText_(): string;
    updateEditable(): void;
    getValue(): string;
    onDispose(): void;
    disposeOfTemporaryAsset(): void;
    clearTemporaryAssetData(): void;
    isTemporaryAsset(): boolean;
    getAsset(): pxt.Asset;
    updateAsset(asset: pxt.Asset): void;
    protected onEditorClose(newValue: pxt.Asset): void;
    protected redrawPreview(): void;
    protected parseValueText(newText: string): void;
    protected parseFieldOptions(opts: U): V;
    protected updateAssetMeta(): void;
    protected updateAssetListener(): void;
    protected assetChangeListener: () => void;
    protected isFullscreen(): boolean;
    protected temporaryAssetId(): string;
}
export declare class BlocklyTilemapChange extends Blockly.Events.BlockChange {
    protected oldRevision: number;
    protected newRevision: number;
    oldAssetId: string;
    newAssetId: string;
    fieldName: string;
    constructor(block: Blockly.Block, element: string, name: string, oldValue: any, newValue: any, oldRevision: number, newRevision: number);
    isNull(): boolean;
    run(forward: boolean): void;
}
export {};
