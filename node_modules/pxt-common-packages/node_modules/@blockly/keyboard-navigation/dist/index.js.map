{"version":3,"file":"index.js","mappings":";CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,sBAC7B,GAAqB,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,gBAAiBJ,OACrB,CACJ,IAAIM,EAAuB,iBAAZL,QAAuBD,EAAQG,QAAQ,iBAAmBH,EAAQD,EAAc,SAC/F,IAAI,IAAIQ,KAAKD,GAAuB,iBAAZL,QAAuBA,QAAUF,GAAMQ,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,MAAOC,qCCTVP,EAAOD,QAAUQ,ICCbC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaZ,QAGrB,IAAIC,EAASQ,EAAyBE,GAAY,CAGjDX,QAAS,CAAC,GAOX,OAHAc,EAAoBH,GAAUV,EAAQA,EAAOD,QAASU,GAG/CT,EAAOD,OACf,CCrBAU,EAAoBK,EAAI,CAACf,EAASgB,KACjC,IAAI,IAAIC,KAAOD,EACXN,EAAoBQ,EAAEF,EAAYC,KAASP,EAAoBQ,EAAElB,EAASiB,IAC5EE,OAAOC,eAAepB,EAASiB,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDP,EAAoBQ,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFd,EAAoBkB,EAAK5B,IACH,oBAAX6B,QAA0BA,OAAOC,aAC1CX,OAAOC,eAAepB,EAAS6B,OAAOC,YAAa,CAAEC,MAAO,WAE7DZ,OAAOC,eAAepB,EAAS,aAAc,CAAE+B,OAAO,GAAO,gRCavD,MAAMC,EAAQ,CACnBC,UAAW,YACXC,OAAQ,SACRC,QAAS,WASEC,EAAiB,CAC5BC,SAAU,WACVC,KAAM,OACNC,GAAI,KACJC,IAAK,MACLC,OAAQ,SACRC,KAAM,OACNC,WAAY,aACZR,QAAS,UACTS,KAAM,OACNC,oBAAqB,sBACrBC,KAAM,oBACNC,IAAK,mBACLC,MAAO,qBACPC,OAAQ,sBACRC,kBAAmB,eACnBC,oBAAqB,iBACrBC,oBAAqB,iBACrBC,qBAAsB,mBAUXC,EAAmB,CAC9BC,MAAO,QACPC,KAAM,OACNC,IAAK,oBCzCA,MAAMC,UAAqB,SAIhC,WAAAC,GACEC,OACF,CAQA,IAAAC,GACE,MAAMC,EAAUvD,KAAKwD,aACrB,IAAKD,EACH,OAAO,KAET,MAAME,EAAUF,EAAQD,OAKxB,OAHIG,GACFzD,KAAK0D,WAAWD,GAEXA,CACT,CAOA,KACE,OAAO,IACT,CAQA,IAAAE,GACE,MAAMJ,EAAUvD,KAAKwD,aACrB,IAAKD,EACH,OAAO,KAET,MAAME,EAAUF,EAAQI,OAKxB,OAHIF,GACFzD,KAAK0D,WAAWD,GAEXA,CACT,CAOA,GAAAG,GACE,OAAO,IACT,EAGK,MAAMC,EAAmB,WAAiBC,KAAKC,OACzCC,EAAmB,eAEhC,WAAiBC,SAASJ,EAAkBG,EAAkBb,GAEvD,MAAMe,EAAa,CACxB,CAACL,GAAmBG,GCrEf,MAAMG,UAAmB,cAI9B,WAAAf,GACEC,OACF,CASA,IAAAC,GACE,MAAMC,EAAUvD,KAAKwD,aACrB,IAAKD,EACH,OAAO,KAET,IAAIE,EAAUzD,KAAKoE,aAAab,EAASvD,KAAKqE,eAc9C,OAVEZ,IACCA,EAAQa,WAAa,UAAgBC,MAAMC,OAC1Cf,EAAQa,WAAa,UAAgBC,MAAMxC,OAC7C0B,EAAQgB,cAAcC,gBAEtBjB,EAAUzD,KAAKoE,aAAaX,EAASzD,KAAKqE,gBAExCZ,GACFzD,KAAK0D,WAAWD,GAEXA,CACT,CASA,KACE,MAAMF,EAAUvD,KAAKwD,aACrB,IAAKD,EACH,OAAO,KAET,MAAME,EAAUzD,KAAKoE,aAAab,EAASvD,KAAK2E,iBAKhD,OAHIlB,GACFzD,KAAK0D,WAAWD,GAEXA,CACT,CAQA,IAAAE,GACE,MAAMJ,EAAUvD,KAAKwD,aACrB,IAAKD,EACH,OAAO,KAET,IAAIE,EAAUzD,KAAK4E,iBAAiBrB,EAASvD,KAAKqE,eAclD,OAXEZ,IACCA,EAAQa,WAAa,UAAgBC,MAAMC,OAC1Cf,EAAQa,WAAa,UAAgBC,MAAMxC,OAC7C0B,EAAQgB,cAAcC,gBAEtBjB,EAAUzD,KAAK4E,iBAAiBnB,EAASzD,KAAKqE,gBAG5CZ,GACFzD,KAAK0D,WAAWD,GAEXA,CACT,CAQA,GAAAG,GACE,MAAML,EAAUvD,KAAKwD,aACrB,IAAKD,EACH,OAAO,KAET,MAAME,EAAUzD,KAAK4E,iBAAiBrB,EAASvD,KAAK2E,iBAKpD,OAHIlB,GACFzD,KAAK0D,WAAWD,GAEXA,CACT,CAUA,aAAAY,CAAcQ,GACZ,IAAKA,EACH,OAAO,EAET,IAAIC,GAAU,EACd,MAAMC,EAAWF,EAAKJ,cAChBO,EAAOH,GAAQA,EAAKP,UAa1B,OAZIU,GAAQ,UAAgBT,MAAMU,MACE,OAA9BF,EAASG,mBACXJ,GAAU,IAGZE,GAAQ,UAAgBT,MAAMC,OAC9BO,EAASC,MAAQ,kBAGRA,GAAQ,UAAgBT,MAAMxC,QADvC+C,GAAU,GAILA,CACT,CASA,eAAAH,CAAgBE,GACd,IAAKA,EACH,OAAO,EAET,IAAIC,GAAU,EACd,MAAMC,EAAWF,EAAKJ,cAChBO,EAAOH,GAAQA,EAAKP,UAS1B,OARIU,GAAQ,UAAgBT,MAAMY,OAGhCH,GAAQ,UAAgBT,MAAMC,OAC9BO,EAASC,MAAQ,iBAHjBF,GAAU,GAOLA,CACT,EAGK,MAAM,EAAmB,aACnB,EAAmB,WAAiBhB,KAAKC,OAEtD,WAAiBE,SAAS,EAAkB,EAAkBE,GAEvD,MAAM,EAAa,CACxB,CAAC,GAAmB,GCtKf,MAAMiB,EAIX,WAAAhC,GAOEpD,KAAKqF,gBAAkB,CAAC,EASxBrF,KAAKsF,gBAAkB,KAOvBtF,KAAKuF,iBAAmB,GAOxBvF,KAAKwF,YAAc,iBASnBxF,KAAKyF,sBAAwB,IAAI,QAAcC,WAAW,IAAK,KAS/D1F,KAAK2F,wBAA0B,IAAI,QAAcD,WAAW,IAAK,KAQjE1F,KAAK4F,gBAAkB5F,KAAK6F,wBAAwBC,KAAK9F,MAQzDA,KAAK+F,oBAAsB/F,KAAKgG,qBAAqBF,KAAK9F,MAQ1DA,KAAKiG,WAAa,EACpB,CAUA,YAAAC,CAAaC,GACXnG,KAAKiG,WAAWG,KAAKD,GACrB,MAAME,EAASF,EAAUG,YACzBH,EACGI,mBACAC,eAAexG,KAAKwF,YAAa,IAAI,UACxCW,EAAUM,kBAAkBzG,KAAK4F,iBAE7BS,GACFrG,KAAK0G,UAAUL,EAEnB,CAQA,eAAAM,CAAgBR,GACd,MAAMS,EAAe5G,KAAKiG,WAAWY,QAAQV,GACvCE,EAASF,EAAUG,YAErBH,EAAUW,aACZ9G,KAAK+G,6BAA6BZ,GAGhCS,GAAgB,GAClB5G,KAAKiG,WAAWe,OAAOJ,EAAc,GAEnCT,EAAUI,oBACZJ,EAAUI,mBAAmBU,iBAAiBjH,KAAKwF,aAErDW,EAAUe,qBAAqBlH,KAAK4F,iBAEhCS,GACFrG,KAAKmH,aAAad,EAEtB,CAQA,QAAAe,CAASjB,EAAWkB,GAClBrH,KAAKqF,gBAAgBc,EAAUmB,IAAMD,CACvC,CAQA,QAAAE,CAASpB,GACP,OAAOnG,KAAKqF,gBAAgBc,EAAUmB,GACxC,CASA,SAAAE,CAAUrB,GACR,OAAOA,EAAUqB,UAAUxH,KAAKwF,YAClC,CASA,SAAAkB,CAAUL,GACR,MAAMoB,EAAkBpB,EAAOqB,eAC/BD,EAAgBhB,kBAAkBzG,KAAK+F,qBACvC,MAAM4B,EAAoB,WAAiBC,SACzC,EACA,GAEFH,EAAgBlB,mBAAmBsB,UAAU,IAAIF,EACnD,CASA,YAAAR,CAAad,GACaA,EAAOqB,eACfR,qBAAqBlH,KAAK+F,oBAC5C,CAQA,uBAAAF,CAAwBiC,GACtB,MAAM3B,EAAY,YAAkB4B,QAAQD,EAAEE,aAC9C,GAAK7B,GAAcA,EAAU8B,0BAG7B,OAAQH,EAAE9C,MACR,KAAK,SAAetC,OAClB1C,KAAKkI,wBAAwB/B,EAAW2B,GACxC,MACF,KAAK,SAAeK,aACA,aAAdL,EAAEM,SACJpI,KAAKqI,oBACHlC,EAC0C,GAG9C,MACF,KAAK,SAAemC,MAClBtI,KAAKuI,qBACHpC,EACoC,GAEtC,MACF,KAAK,SAAeqC,oBAClBxI,KAAKyI,2BACHtC,EACgD,GAElD,MACF,KAAK,SAAeuC,aAClB1I,KAAK2I,kBAAkBxC,EAAW2B,GAExC,CAQA,oBAAA9B,CAAqB8B,GACnB,MAAML,EAAkB,YAAkBM,QAAQD,EAAEE,aAC9CY,EAAgBnB,EAAgBoB,gBAChCxC,EAASuC,EAActC,YAK7B,GACEsC,GACAA,EAAcX,4BACb5B,EAAOyC,UAER,GAAIhB,EAAE9C,OAAS,SAAesD,OAA0B,UAAjBR,EAAEiB,WAAwB,CAC/D,MAAMC,EAAQvB,EAAgBwB,aAAanB,EAAEoB,SAC7ClJ,KAAKmJ,yBAAyBP,EAAeI,EAC/C,MAAO,GAAIlB,EAAE9C,OAAS,SAAeoE,SAAU,CAC7C,MAAMJ,EAAQvB,EAAgBwB,aAAanB,EAAEuB,cAC7CrJ,KAAKmJ,yBAAyBP,EAAeI,EAC/C,CAEJ,CAWA,iBAAAL,CAAkBxC,EAAW2B,GACvB9H,KAAKuH,SAASpB,KAAe,EAAgBxE,SAC/C3B,KAAKsJ,YAAYnD,IAAaA,EAAUoD,cACxCvJ,KAAKoH,SAASjB,EAAW,EAAgBzE,WAE7C,CAUA,mBAAA2G,CAAoBlC,EAAW2B,GAC7B,MAAM0B,EAAiB1B,EAAEoB,QACnBO,EAAStD,EAAUW,YACzB,GAAI2C,EAAQ,CACV,MAAMlG,EAAUkG,EAAOjG,aACjBwF,EAAQzF,EAAUA,EAAQmG,iBAAmB,KAC/CV,GAASA,EAAM1B,KAAOkC,GACxBC,EAAO/F,WAAW,UAAgBiG,gBAAgBX,GAEtD,CACF,CASA,oBAAAT,CAAqBpC,EAAW2B,GACP9H,KAAKuH,SAASpB,KACd,EAAgBzE,YACrC1B,KAAKsJ,YAAYnD,IAAaA,EAAUoD,cACxCvJ,KAAKoH,SAASjB,EAAW,EAAgBzE,WAE7C,CAUA,0BAAA+G,CAA2BtC,EAAW2B,GACpC,MAAM8B,EAAiB5J,KAAKuH,SAASpB,GACjC2B,EAAE+B,SAAWD,IAAmB,EAAgBhI,QAElD5B,KAAK8J,aAAa3D,GACR2B,EAAE+B,UAEZ7J,KAAKsJ,YAAYnD,IAAaA,EAAUoD,cACxCvJ,KAAKoH,SAASjB,EAAW,EAAgBzE,WAE7C,CAUA,uBAAAwG,CAAwB/B,EAAW2B,GACjC,MAAMiC,EAAiBjC,EAAEoB,QACnBc,EAAMlC,EAAEkC,IACRP,EAAStD,EAAUW,YAGzB,IACG2C,IACAA,EAAOjG,eACPiG,EAAOjG,aAAakG,iBAErB,OAGF,MACMO,EADUR,EAAOjG,aACKkG,kBACxBO,EAAY3C,KAAOyC,GAAkBC,EAAInD,QAAQoD,EAAY3C,KAAO,IACtEmC,EAAO/F,WACL,UAAgBwG,oBACd/D,EACAnG,KAAK2F,yBAIb,CAUA,wBAAAwD,CAAyBP,EAAeI,GACjCA,IAGDA,EAAMmB,aACRnB,EAAwCA,EAAMoB,aAEhDpK,KAAKqK,gBAAgBzB,GAAelF,WAClC,UAAgB4G,gBAAgBtB,IAElChJ,KAAKoH,SAASwB,EAAe,EAAgBjH,QAC/C,CAWA,uBAAA4I,CAAwBpE,EAAWqE,GACjC,IAAKrE,IAAcA,EAAUW,YAC3B,OAEF,MAAM2C,EAAStD,EAAUW,YACnBvD,EAAUkG,EAAOjG,aACjBwF,EAAQzF,EAAUA,EAAQmG,iBAAmB,KAEnD,GAAIV,IAAUwB,EAEZ,GAAIxB,EAAMoB,YAAa,CACrB,MAAMK,EACJzB,EAAM0B,oBAAsB1B,EAAM9D,iBAChCuF,GACFhB,EAAO/F,WACL,UAAgBiH,qBACdF,EAAcG,kBAItB,MAEEnB,EAAO/F,WACL,UAAgBwG,oBACdlB,EAAM7C,UACN6C,EAAM6B,gCAMH7B,GAASwB,EAAaM,aAAY,GAAOjE,QAAQmC,IAAU,GACpES,EAAO/F,WACL,UAAgBwG,oBACdlB,EAAM7C,UACN6C,EAAM6B,0BAId,CASA,YAAAf,CAAa3D,GACX,MAAM4E,EAAU5E,EAAUoD,aAC1B,GAAKwB,IAIL/K,KAAKoH,SAASjB,EAAW,EAAgBvE,SACzC5B,KAAKsJ,YAAYnD,GAAW,GAEvBnG,KAAKwH,UAAUrB,GAAW3C,cAC7BxD,KAAKgL,aAAa7E,IAGf4E,EAAQE,mBAAmB,CAE9B,MAAMC,EAAeH,EAAQI,kBAC7B,IAAK,IAAWC,EAAPrL,EAAI,EAAiBqL,EAAcF,EAAanL,GAAKA,IAC5D,GAAIqL,EAAYC,eAAgB,CAC9BN,EAAQO,qBAAqBvL,GAC7B,KACF,CAEJ,CACF,CAQA,WAAAwL,CAAYpF,GACV,MAAME,EAASF,EAAUG,YAQzB,GANAtG,KAAKoH,SAASjB,EAAW,EAAgBxE,QAEpC3B,KAAKwH,UAAUrB,GAAW3C,cAC7BxD,KAAKgL,aAAa7E,GAGhBE,GAAUA,EAAOqB,eAAgB,CACnC,MACM8D,EADiBnF,EAAOoF,cACS,GACvC,IAAKD,EAAiB,OACtB,GAAIA,EAAgBE,OAAQ,CAC1B,MAAMC,EAAU,UAAgBC,iBAC9BJ,EAAgBE,QAElB1L,KAAKqK,gBAAgBlE,GAAWzC,WAAWiI,EAC7C,MAAO,GAAIH,EAAgBxC,MAAO,CAChC,MAAM2C,EAAU,UAAgBrB,gBAAgBkB,EAAgBxC,OAChEhJ,KAAKqK,gBAAgBlE,GAAWzC,WAAWiI,EAC7C,CACF,CACF,CAQA,cAAAE,CAAe1F,GACbA,EAAU2F,YACV,MAAMC,IAAU5F,EAAUoD,aAE1BvJ,KAAKsJ,YAAYnD,EAAW4F,GAC5B/L,KAAKoH,SAASjB,EAAW,EAAgBzE,WACzC1B,KAAKgM,0BAA0B7F,EACjC,CASA,yBAAA6F,CAA0B7F,GACxB,MAAM8F,EAAY9F,EAAU+F,cAAa,GACnCzC,EAAStD,EAAUW,YACnBqF,EAAgB,IAAI,QAAczG,WACtC1F,KAAKyF,sBAAsB2G,EAAIjG,EAAUkG,MACzCrM,KAAKyF,sBAAsB6G,EAAInG,EAAUkG,OAE3C,GAAIJ,EAAUM,OAAS,EACrB9C,EAAO/F,WAAW,UAAgB8I,cAAcP,EAAU,SACrD,CACL,MAAMQ,EAAS,UAAgBvC,oBAC7B/D,EACAgG,GAEF1C,EAAO/F,WAAW+I,EACpB,CACF,CAUA,eAAApC,CAAgBlE,GACd,MAAME,EAASF,EAAUG,YAGzB,OAFeD,EAASA,EAAOqB,eAAeZ,YAAc,IAG9D,CAWA,gBAAA4F,CAAiBvG,GACf,MAAMwG,EAAW3M,KAAK4M,eAAezG,GACrC,IAAKwG,EACH,OAEF,MAAME,EAAa7M,KAAKwH,UAAUrB,GAAW3C,aAE1CxD,KAAK8M,4BACJ3G,EACA0G,EACA,UAAgBlD,gBAAgBgD,KAGlC3M,KAAK+M,KACH,iEAIJ/M,KAAK6L,eAAe1F,GACpBA,EAAUW,YAAYpD,WAAW,UAAgB8I,cAAcG,IAC/D3M,KAAKgN,WAAW7G,EAClB,CASA,cAAAyG,CAAezG,GACb,MAAME,EAASF,EAAUG,YACzB,IAAKD,IAAWA,EAAO4G,YAKrB,OAJAjN,KAAK+M,KACH,sFAGK,KAGT,MAAMG,EACJlN,KAAKqK,gBAAgBlE,GAAW3C,aAAaiB,cAE/C,IAAKyI,EAASC,YAEZ,OADAnN,KAAK+M,KAAK,kCACH,KAGT,MAAMJ,EAAWtG,EAAO+G,YAAYF,GAOpC,OALAP,EAASU,SAITV,EAASW,uBAAsB,GACxBX,CACT,CAQA,WAAArD,CAAYnD,EAAWoH,GACjBvN,KAAKqK,gBAAgBlE,KACvBnG,KAAKqK,gBAAgBlE,GAAWqH,OAC5BD,GACFpH,EAAUG,YAAYkH,OAG5B,CAUA,sBAAAC,CAAuBtH,GACrB,MAAM0G,EAAa7M,KAAKwH,UAAUrB,GAAW3C,aACvCkK,EAAavH,EAAUW,YAAYtD,aAEzC,SAAIqJ,IAAca,IACT1N,KAAK8M,4BACV3G,EACA0G,EACAa,EAIN,CAWA,2BAAAZ,CAA4B3G,EAAW0G,EAAYa,GACjD,IAAK1N,KAAK2N,qBAAqBd,EAAYa,GACzC,OAAO,EAGT,MAAME,EAAaf,EAAWvI,UACxBuJ,EAAaH,EAAWpJ,UAExBwJ,EAAYJ,EAAWjJ,cACvBsJ,EAAYlB,EAAWpI,cAC7B,GAAIoI,EAAWmB,gBAAkBN,EAAWM,eAAgB,CAC1D,MAAMC,EAA8D,EAG9DC,EAA8D,EAGpE,OAAOlO,KAAKmO,QAAQF,EAAkBC,EACxC,CAAO,GACLrB,EAAWmB,iBACVH,GAAc,UAAgBtJ,MAAMU,OACnC4I,GAAc,UAAgBtJ,MAAM6J,OACtC,CACA,MAAMC,EAA+C,EAC/CH,EAA8D,EAGpE,OAAOlO,KAAKsO,YAAYD,EAAaH,EACvC,CAAO,GAAIN,GAAc,UAAgBrJ,MAAM7C,UAAW,CACxD,MAAMsH,EAAQ0E,EAAaA,EAAWhE,iBAAmB,KACzD,OAAO1J,KAAKuO,qBACsB,EAChC1B,EAEJ,CAEA,OADA7M,KAAK+M,KAAK,qDACH,CACT,CAUA,oBAAAY,CAAqBd,EAAYa,GAC/B,IAAKb,EAEH,OADA7M,KAAK+M,KAAK,uCACH,EAGT,IAAKW,EAEH,OADA1N,KAAK+M,KAAK,uCACH,EAET,MAAMa,EAAaf,EAAWvI,UACxBuJ,EAAaH,EAAWpJ,UAG9B,OAAIsJ,GAAc,UAAgBrJ,MAAMY,OACtCnF,KAAK+M,KAAK,+CACH,GACEa,GAAc,UAAgBrJ,MAAMU,OAC7CjF,KAAK+M,KAAK,+CACH,GACEa,GAAc,UAAgBrJ,MAAM6J,OAC7CpO,KAAK+M,KAAK,+CACH,GAILc,GAAc,UAAgBtJ,MAAMY,OACtCnF,KAAK+M,KAAK,4CACH,GACEc,GAAc,UAAgBtJ,MAAM7C,YAC7C1B,KAAK+M,KAAK,gDACH,EAGX,CAYA,oBAAAwB,CAAqBvF,EAAOyD,GAC1B,QAAKzD,IAGDA,EAAMmB,YACRnK,KAAK+M,KAAK,iDACH,IAEL/D,EAAMoB,aACRpB,EAAMwF,QAAO,GAEfxF,EAAMyF,OAAOhC,EAAOiC,oBACb,GACT,CAWA,eAAAC,CAAgBC,EAAkBC,GAChC,MAAMC,EAAcF,EAAiBlF,iBAC/BqF,EAAYF,EAAenF,iBACjC,IAAIsF,EAEAF,EAAYG,iBAAmBF,EAAUE,iBACvCH,EAAYI,gBAAe,GAAOrI,QAAQkI,IAAc,GAC1DC,EAAqBhP,KAAKmP,sBAAsBN,GAC5CG,GACFA,EAAmBI,eAGrBJ,EAAqBhP,KAAKmP,sBAAsBP,GAC5CI,GACFA,EAAmBI,cAI3B,CAeA,OAAAjB,CAAQS,EAAkBC,GACxB,IAAKD,IAAqBC,EACxB,OAAO,EAGT,MAAMQ,EAAiBrP,KAAKmP,sBAAsBP,GAC5CU,EAAetP,KAAKuP,sBAAsBV,GAE1CW,EAAiBxP,KAAKuP,sBAAsBX,GAC5Ca,EAAezP,KAAKmP,sBAAsBN,GAEhD,GACEQ,GACAC,GACAtP,KAAK0P,eAAeL,EAAgBC,GAEpC,OAAO,EAEF,GACLE,GACAC,GACAzP,KAAK0P,eAAeF,EAAgBC,GAEpC,OAAO,EACF,GAAIzP,KAAK0P,eAAed,EAAkBC,GAC/C,OAAO,EACF,CACL,MAAMc,EAAUf,EAAiBgB,uBAC3BC,EAASF,EAAQG,qBACrBlB,EACAC,GACA,GAMF,OAJA7O,KAAK+M,KACH,iCACE4C,EAAQI,gBAAgBF,EAAQjB,EAAkBC,KAE/C,CACT,CACF,CAWA,qBAAAM,CAAsBa,GACpB,MAAMhH,EAAyCgH,EAAWtG,iBAC1D,OAAKsG,EAAWC,aAELjH,EAAM0B,mBACR1B,EAAM0B,mBACJ1B,EAAM9D,iBACR8D,EAAM9D,iBAEN,KANA8K,CAQX,CAWA,qBAAAT,CAAsBS,GACpB,OAAIA,EAAWC,aACND,EACEA,EAAWpF,iBACboF,EAAWpF,iBAEb,IACT,CAWA,cAAA8E,CAAed,EAAkBC,GAC/B,IAAKD,IAAqBC,EACxB,OAAO,EAET,MAAMC,EAAcF,EAAiBlF,iBAGrC,GAFgBkF,EAAiBgB,uBAGvBM,WAAWtB,EAAkBC,GAAgB,KACpDA,EAAenF,iBAAiBS,WACjC,CAKA,GAJAnK,KAAK2O,gBAAgBC,EAAkBC,IAIlCA,EAAeoB,aAAc,CAChC,MAAME,EAAYrB,EAAYG,eAExBmB,EAAyB,CAC7BhE,EAAGyC,EAAezC,EAAIwC,EAAiBxC,EACvCE,EAAGuC,EAAevC,EAAIsC,EAAiBtC,GAEnC+D,EAAwBzB,EAC3B0B,mBACAC,QACHJ,EAAUK,uBACR5B,EACAwB,EACAC,EAEJ,CAEA,OADAxB,EAAeV,QAAQS,IAChB,CACT,CACA,OAAO,CACT,CAWA,WAAAN,CAAYtF,EAAO6F,GACjB,OAAQA,EAAe7J,MACrB,KAAK,qBACH,GAAIhF,KAAKmO,QAAQnF,EAAMyH,eAAgB5B,GACrC,OAAO,EAET,MACF,KAAK,iBACH,GAAI7O,KAAKmO,QAAQnF,EAAM0B,mBAAoBmE,GACzC,OAAO,EAET,MACF,KAAK,cACH,GAAI7O,KAAKmO,QAAQnF,EAAM9D,iBAAkB2J,GACvC,OAAO,EAET,MACF,KAAK,eACH,IAAK,IAAI9O,EAAI,EAAGA,EAAIiJ,EAAM0H,UAAUnE,OAAQxM,IAAK,CAC/C,MAAM4Q,EACJ3H,EAAM0H,UAAU3Q,GAClB,WACA,GACE4Q,GACAA,EAAgB3L,OAAS,eACzBhF,KAAKmO,QAAQwC,EAAiB9B,GAE9B,OAAO,CAEX,CAGA,GACE7F,EAAM9D,kBACNlF,KAAKmO,QAAQnF,EAAM9D,iBAAkB2J,GAErC,OAAO,EAKb,OADA7O,KAAK+M,KAAK,2DACH,CACT,CASA,gBAAA6D,CAAiBzK,GACf,MAAM5C,EAAU4C,EAAUW,YAAYtD,aACtC,IAAKD,EAAQyK,eAIX,YAHAhO,KAAK6Q,IACH,mEAIJ,MAAMC,EACJvN,EAAQkB,cAEV,IAAKqM,EAAcC,cAEjB,YADA/Q,KAAK6Q,IAAI,4CAGX,MAAMG,EAAqBF,EAAcb,aACrCa,EACAA,EAAclG,iBAEZoE,EAAqB8B,EAAcb,aACrCa,EAAclG,iBACdkG,EAEJ,GAAI9B,EAAmBtF,iBAAiBS,WAEtC,YADAnK,KAAK6Q,IAAI,oCAGXG,EAAmB5B,aACnBJ,EAAmBiC,aAAaD,GAEdA,EAAmBtH,iBAAiBuF,eAC5CiC,eAEV,MAAMC,EACJ,UAAgBxG,qBAAqBqG,GACvC7K,EAAUW,YAAYpD,WAAWyN,EACnC,CAOA,YAAAnG,CAAa7E,GACXnG,KAAKwH,UAAUrB,GAAWzC,WAAWyC,EAAUW,YAAYtD,aAC7D,CAOA,UAAAwJ,CAAW7G,GACT,MAAMiL,EAASpR,KAAKwH,UAAUrB,GAC9BiL,EAAO1N,WAAW,MAClB0N,EAAO5D,MACT,CAQA,2BAAA6D,CAA4BlL,GAExBnG,KAAKiG,WAAWY,QAAQV,IAAc,IACrCA,EAAU8B,4BAEX9B,EAAU8B,2BAA4B,EACtCjI,KAAK6L,eAAe1F,GAExB,CAQA,4BAAAY,CAA6BZ,GAEzBnG,KAAKiG,WAAWY,QAAQV,IAAc,GACtCA,EAAU8B,4BAEV9B,EAAU8B,2BAA4B,EACtC9B,EAAUW,YAAY0G,OACtBxN,KAAKwH,UAAUrB,GAAWqH,OACtBxN,KAAKqK,gBAAgBlE,IACvBnG,KAAKqK,gBAAgBlE,GAAWqH,OAGtC,CAQA,GAAAqD,CAAIS,GACEtR,KAAKsF,gBACPtF,KAAKsF,gBAAgB,EAA2BpC,IAAKoO,GAErDC,QAAQV,IAAIS,EAEhB,CAQA,IAAAvE,CAAKuE,GACCtR,KAAKsF,gBACPtF,KAAKsF,gBAAgB,EAA2BrC,KAAMqO,GAEtDC,QAAQxE,KAAKuE,EAEjB,CAQA,KAAAE,CAAMF,GACAtR,KAAKsF,gBACPtF,KAAKsF,gBAAgB,EAA2BtC,MAAOsO,GAEvDC,QAAQC,MAAMF,EAElB,CAWA,YAAAG,CAAatL,EAAWuL,EAAYC,GAClC,MAAMlI,EAAStD,EAAUW,YACnBvD,EAAU4C,EAAUW,YAAYtD,aAEtC,GAAID,EAAQe,YAAc,UAAgBC,MAAM7C,UAC9C,OAAO,EAGT,MAAMkQ,EAAUrO,EAAQmL,kBAClBmD,EAAOH,EAAa1R,KAAKuF,iBAAmBqM,EAAQxF,EACpD0F,EAAOH,EAAa3R,KAAKuF,iBAAmBqM,EAAQtF,EAQ1D,OANA7C,EAAO/F,WACL,UAAgBwG,oBACd/D,EACA,IAAI,QAAcT,WAAWmM,EAAMC,MAGhC,CACT,CAOA,gBAAAC,CAAiB5L,GACf,MACM5C,EADS4C,EAAUW,YACFtD,aACjBwO,EAAWzO,EAAQe,UACrB0N,GAAY,UAAgBzN,MAAMY,MACL5B,EAAQkB,cAAewN,aAEtD1O,EAAQyK,gBACRgE,GAAY,UAAgBzN,MAAM7C,UAElC1B,KAAKgL,aAAa7E,GACT6L,GAAY,UAAgBzN,MAAMU,MAC3CjF,KAAK+M,KAAK,wBACDiF,GAAY,UAAgBzN,MAAM6J,OAC3CpO,KAAK+M,KAAK,uBAEd,CAWA,KAAAmF,CAAMC,EAAUhM,GACd,IAAIiM,GAAY,EAChB,SAAeC,UAAS,GACxB,MAAMrJ,EACJ,YAAkBkJ,MAAMC,EAAUhM,GAMpC,OAJI6C,IACFoJ,EAAYpS,KAAKsS,kBAAkBnM,EAAW6C,IAEhD,SAAeqJ,UAAS,GACjBD,CACT,CAaA,iBAAAE,CAAkBnM,EAAW6C,GAC3B,IAAIoJ,GAAY,EAChB,MAAMG,EAAapM,EAAUqB,UAAUxH,KAAKwF,aAAahC,aAQzD,OAPI+O,IACFH,EAAYpS,KAAK8M,4BACf3G,EACAoM,EACA,UAAgB5I,gBAAgBX,KAG7BoJ,CACT,CAQA,qBAAAI,CAAsBrM,GACpB,MAAMuF,EACJ1L,KAAKqK,gBAAgBlE,GAAW3C,aAAaiB,cAEzCgO,EAAiBtM,EAAUuM,sBAAsB3R,IACrD2K,EAAOiH,aAET,GAA8B,mBAAnBF,EAGT,MAAM,IAAIG,MAAM,iDAFhBH,EAAe/G,EAInB,CAMA,OAAAmH,GACE,IAAK,MAAM1M,KAAanG,KAAKiG,WAC3BjG,KAAK2G,gBAAgBR,EAEzB,ECrvCF,MAAM2M,EAAsB,UAAgB5R,UAAU6R,kBAStD,UAAgB7R,UAAU6R,kBAAoB,SAAUjL,GACtDgL,EAAoB1R,KAAKpB,KAAM8H,GAC/B,MAAMkL,EAAKhT,KAAKiT,kBAChB,GAAInL,EAAEoL,UAAYF,EAAG/K,0BAA2B,CAC9C,MAAMkL,EAAc,IAAI,QAAczN,WAAWoC,EAAEsL,QAAStL,EAAEuL,SACxDzB,EAAU,QAAc0B,QAAQC,sBACpCP,EACAG,GAEI1G,EAAS,UAAgBvC,oBAAoB8I,EAAIpB,GACvDoB,EAAGlM,YAAYpD,WAAW+I,EAC5B,CACF,EAEA,MAAM+G,EAAkB,UAAgBtS,UAAUuS,cAQlD,UAAgBvS,UAAUuS,cAAgB,SAAU3L,GAClD0L,EAAgBpS,KAAKpB,KAAM8H,IAExB9H,KAAK0T,aAAaC,YACnB3T,KAAK4T,iBAAiBV,UACtBlT,KAAK0T,aAAavN,UAAU8B,2BAE5BjI,KAAKiT,kBACFnM,YACApD,WAAW,UAAgB8I,cAAcxM,KAAK0T,cAErD,ECpCO,MAAMG,EAEX1B,SAAW,KAGX2B,cAAgB,KAShB,WAAA1Q,CAAY2Q,GAMV/T,KAAKgU,WAAaD,GAAiB,IAAI3O,CACzC,CAMA,IAAA6O,GACEjU,KAAKkU,sBACLlU,KAAKmU,kBACP,CAOA,mBAAAD,GACM,gBACF,cAAoBhT,UAAUkT,WAAapU,KAAKqU,oBAG9C,kBACF,gBAAsBnT,UAAUkT,WAAapU,KAAKsU,sBAGhD,YACF,UAAgBpT,UAAUkT,WAAapU,KAAKuU,eAEhD,CAOA,sBAAAC,GACM,gBACF,cAAoBtT,UAAUkT,WAAa,MAGzC,kBACF,gBAAsBlT,UAAUkT,WAAa,MAG3C,YACF,UAAgBlT,UAAUkT,WAAa,KAE3C,CAYA,kBAAAC,CAAmBI,GACjB,GAAIzU,KAAK0U,QACP,OAAQD,EAASE,MACf,KAAK,EAAyB7S,SAE5B,OADA9B,KAAK4U,iBAAiB,GAAI,IACnB,EACT,KAAK,EAAyB7S,KAE5B,OADA/B,KAAK4U,iBAAiB,EAAG,IAClB,EACT,KAAK,EAAyB3S,IAE5B,OADAjC,KAAK4U,kBAAkB,EAAG,IACnB,EACT,KAAK,EAAyB5S,GAE5B,OADAhC,KAAK4U,iBAAiB,EAAG,IAClB,EACT,QACE,OAAO,EAKb,OAAO,QAAc1T,UAAUkT,WAAWhT,KAAKpB,KAAMyU,EACvD,CAYA,oBAAAH,CAAqBG,GACnB,GAAIzU,KAAK6U,MACP,OAAQJ,EAASE,MACf,KAAK,EAAyB7S,SAE5B,OADA9B,KAAK6U,MAAMC,qBACJ,EACT,KAAK,EAAyB/S,KAE5B,OADA/B,KAAK6U,MAAME,iBACJ,EACT,QACE,OAAO,EAKb,OAAO,QAAc7T,UAAUkT,WAAWhT,KAAKpB,KAAMyU,EACvD,CAYA,cAAAF,CAAeE,GACb,IAAKzU,KAAKgV,cACR,OAAO,EAET,OAAQP,EAASE,MACf,KAAK,EAAyB7S,SAC5B,OAAO9B,KAAKiV,kBACd,KAAK,EAAyBhT,IAC5B,OAAOjC,KAAKkV,gBACd,KAAK,EAAyBnT,KAC5B,OAAO/B,KAAKmV,cACd,KAAK,EAAyBnT,GAC5B,OAAOhC,KAAKoV,eACd,QACE,OAAO,EAEb,CAUA,YAAAlP,CAAaC,GACXnG,KAAKgU,WAAW9N,aAAaC,EAC/B,CASA,eAAAQ,CAAgBR,GACdnG,KAAKgU,WAAWrN,gBAAgBR,EAClC,CAQA,MAAAkP,CAAOlP,GACLnG,KAAKgU,WAAW3C,4BAA4BlL,EAC9C,CAQA,OAAAmP,CAAQnP,GACNnG,KAAKgU,WAAWjN,6BAA6BZ,EAC/C,CAWA,oBAAAoP,CAAqBpP,EAAWsO,GAC9B,MAAMhL,EAAStD,EAAUW,YACzB,IAAK2C,IAAWA,EAAOjG,aACrB,OAAO,EAET,MAAMD,EAAUkG,EAAOjG,aACvB,OAAID,EAAQe,YAAc,UAAgBC,MAAMY,OACR5B,EAAQkB,cAAe2P,WAC3DK,EAIN,CAOA,gBAAAe,GAEE,MAAMC,EAAmB,CACvBd,KAAM,EAAyB7S,SAC/B4T,eAAiBvP,GACRA,EAAU8B,0BAEnB0N,SAAU,CAACxP,EAAW2B,EAAG2M,KACvB,MAAMpO,EAASF,EAAUG,YACnByE,EAAU5E,EAAUoD,aAC1B,IAAI6I,GAAY,EAChB,OAAQpS,KAAKgU,WAAWzM,SAASpB,IAC/B,KAAK,EAAgBzE,UAMnB,OALA0Q,EAAYpS,KAAKuV,qBAAqBpP,EAAWsO,GAC5CrC,IACHjM,EAAUW,YAAYnD,OACtByO,GAAY,GAEPA,EACT,KAAK,EAAgBzQ,OAMnB,OALAyQ,EAAYpS,KAAKuV,qBAAqBpP,EAAWsO,GAC5CrC,IACH/L,EAAOqB,eAAeZ,YAAYnD,OAClCyO,GAAY,GAEPA,EACT,KAAK,EAAgBxQ,QACnB,SAAOmJ,GAAwC,mBAAtBA,EAAQqJ,aAC7BrJ,EAAQqJ,WAAWK,GAEzB,QACE,OAAO,EACX,GAIJ,mBAAyBmB,SAAS3R,SAASwR,GAC3C,mBAAyBG,SAASC,cAChC,QAAcC,SAASC,EACvBN,EAAiBd,KAErB,CAMA,yBAAAqB,GAEE,MAAMC,EAA4B,CAChCtB,KAAM,EAAyBrS,oBAC/BqT,SAAWxP,IACLA,EAAU8B,0BACZjI,KAAKgU,WAAWjN,6BAA6BZ,GAE7CnG,KAAKgU,WAAW3C,4BAA4BlL,IAEvC,IAIX,mBAAyByP,SAAS3R,SAASgS,GAC3C,MAAMC,EAAa,mBAAyBN,SAASO,oBACnD,QAAcL,SAASM,EACvB,CAAC,QAAcN,SAASO,KAAM,QAAcP,SAASQ,QAEvD,mBAAyBV,SAASC,cAChCK,EACAD,EAA0BtB,KAE9B,CAOA,WAAA4B,GAEE,MAAMC,EAAc,CAClB7B,KAAM,EAAyB1S,IAC/ByT,eAAiBvP,GACRA,EAAU8B,0BAEnB0N,SAAU,CAACxP,EAAW2B,EAAG2M,KACvB,MAAM1J,EAAU5E,EAAUoD,aAC1B,IAAI6I,GAAY,EAChB,OAAQpS,KAAKgU,WAAWzM,SAASpB,IAC/B,KAAK,EAAgBzE,UAMnB,OALA0Q,EAAYpS,KAAKuV,qBAAqBpP,EAAWsO,GAC5CrC,IACHjM,EAAUW,YAAYlD,MACtBwO,GAAY,GAEPA,EACT,KAAK,EAAgBzQ,OAEnB,OADA3B,KAAKgU,WAAWlK,aAAa3D,IACtB,EACT,KAAK,EAAgBvE,QACnB,SAAOmJ,GAAwC,mBAAtBA,EAAQqJ,aAC7BrJ,EAAQqJ,WAAWK,GAEzB,QACE,OAAO,EACX,GAIJ,mBAAyBmB,SAAS3R,SAASuS,GAC3C,mBAAyBZ,SAASC,cAChC,QAAcC,SAASW,EACvBD,EAAY7B,KAEhB,CAOA,YAAA+B,GAEE,MAAMC,EAAe,CACnBhC,KAAM,EAAyB5S,KAC/B2T,eAAiBvP,GACRA,EAAU8B,0BAEnB0N,SAAU,CAACxP,EAAW2B,EAAG2M,KACvB,MAAM1J,EAAU5E,EAAUoD,aACpBlD,EAASF,EAAUG,YACzB,IAAI8L,GAAY,EAChB,OAAQpS,KAAKgU,WAAWzM,SAASpB,IAC/B,KAAK,EAAgBzE,UAMnB,OALA0Q,EAAYpS,KAAKuV,qBAAqBpP,EAAWsO,GAC5CrC,IACHjM,EAAUW,YAAYxD,OACtB8O,GAAY,GAEPA,EACT,KAAK,EAAgBzQ,OAMnB,OALAyQ,EAAYpS,KAAKuV,qBAAqBpP,EAAWsO,GAC5CrC,IACH/L,EAAOqB,eAAeZ,YAAYxD,OAClC8O,GAAY,GAEPA,EACT,KAAK,EAAgBxQ,QACnB,SAAOmJ,GAAwC,mBAAtBA,EAAQqJ,aAC7BrJ,EAAQqJ,WAAWK,GAEzB,QACE,OAAO,EACX,GAIJ,mBAAyBmB,SAAS3R,SAAS0S,GAC3C,mBAAyBf,SAASC,cAChC,QAAcC,SAASc,EACvBD,EAAahC,KAEjB,CAOA,UAAAkC,GAEE,MAAMC,EAAa,CACjBnC,KAAM,EAAyB3S,GAC/B0T,eAAiBvP,GACRA,EAAU8B,0BAEnB0N,SAAU,CAACxP,EAAW2B,EAAG2M,KACvB,MAAM1J,EAAU5E,EAAUoD,aAC1B,IAAI6I,GAAY,EAChB,OAAQpS,KAAKgU,WAAWzM,SAASpB,IAC/B,KAAK,EAAgBzE,UAMnB,OALA0Q,EAAYpS,KAAKuV,qBAAqBpP,EAAWsO,GAC5CrC,IACHjM,EAAUW,YAAYiQ,KACtB3E,GAAY,GAEPA,EACT,KAAK,EAAgBxQ,QAQnB,OAPAwQ,KACErH,GAAwC,mBAAtBA,EAAQqJ,aACtBrJ,EAAQqJ,WAAWK,GAEpBrC,GACHpS,KAAKgU,WAAWzI,YAAYpF,IAEvB,EACT,QACE,OAAO,EACX,GAIJ,mBAAyByP,SAAS3R,SAAS6S,GAC3C,mBAAyBlB,SAASC,cAChC,QAAcC,SAASkB,EACvBF,EAAWnC,KAEf,CAOA,cAAAsC,GAEE,MAAMC,EAAiB,CACrBvC,KAAM,EAAyBzS,OAC/BwT,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACDnG,KAAKgU,WAAWzM,SAASpB,KAC1B,EAAgBzE,WACZ1B,KAAKgU,WAAWvG,uBAAuBtH,IAOtD,mBAAyByP,SAAS3R,SAASiT,GAC3C,mBAAyBtB,SAASC,cAChC,QAAcC,SAASuB,EACvBH,EAAevC,KAEnB,CAMA,YAAA2C,GAEE,MAAMC,EAAe,CACnB5C,KAAM,EAAyBxS,KAC/BuT,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,IACT,IAAIqR,EACAjU,EACAyO,EAEJ,OAAQhS,KAAKgU,WAAWzM,SAASpB,IAC/B,KAAK,EAAgBzE,UAEnB,OADA1B,KAAKgU,WAAWjC,iBAAiB5L,IAC1B,EACT,KAAK,EAAgBxE,OAEnB,GADA6V,EAAexX,KAAKgU,WAAW3J,gBAAgBlE,IAC1CqR,EACH,OAAO,EAKT,OAHAjU,EAAUiU,EAAahU,aACvBwO,EAAWzO,EAAQe,UAEX0N,GACN,KAAK,UAAgBzN,MAAM6J,MACzBpO,KAAKgU,WAAWtH,iBAAiBvG,GACjC,MACF,KAAK,UAAgB5B,MAAMkT,OACzBzX,KAAKgU,WAAWxB,sBAAsBrM,GAI1C,OAAO,EACT,QACE,OAAO,EACX,GAIJ,mBAAyByP,SAAS3R,SAASsT,GAC3C,mBAAyB3B,SAASC,cAChC,QAAcC,SAAS4B,MACvBH,EAAa5C,KAEjB,CAOA,kBAAAgD,GAEE,MAAMC,EAAqB,CACzBjD,KAAM,EAAyBvS,WAC/BsT,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACDnG,KAAKgU,WAAWzM,SAASpB,KAC1B,EAAgBzE,YACnB1B,KAAKgU,WAAWpD,iBAAiBzK,IAC1B,IAOf,mBAAyByP,SAAS3R,SAAS2T,GAC3C,mBAAyBhC,SAASC,cAChC,QAAcC,SAAS+B,EACvBD,EAAmBjD,KAEvB,CAOA,oBAAAmD,GAEE,MAAMC,EAAuB,CAC3BpD,KAAM,EAAyB/S,QAC/B8T,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACDnG,KAAKgU,WAAWzM,SAASpB,KAC1B,EAAgBzE,YACdyE,EAAUoD,aAGbvJ,KAAKgU,WAAWlK,aAAa3D,GAF7BnG,KAAKgU,WAAWzI,YAAYpF,IAIvB,IAOf,mBAAyByP,SAAS3R,SAAS8T,GAC3C,mBAAyBnC,SAASC,cAChC,QAAcC,SAASkC,EACvBD,EAAqBpD,KAEzB,CAOA,YAAAsD,GAEE,MAAMC,EAAe,CACnBvD,KAAM,EAAyBtS,KAC/BqT,eAAiBvP,GACRA,EAAU8B,0BAEnB0N,SAAWxP,IACT,OAAQnG,KAAKgU,WAAWzM,SAASpB,IAC/B,KAAK,EAAgBxE,OAGrB,KAAK,EAAgBC,QAEnB,OADA5B,KAAKgU,WAAWnI,eAAe1F,IACxB,EACT,QACE,OAAO,EACX,GAIJ,mBAAyByP,SAAS3R,SAASiU,GAAc,GACzD,mBAAyBtC,SAASC,cAChC,QAAcC,SAASqC,IACvBD,EAAavD,MACb,GAEF,mBAAyBiB,SAASC,cAChC,QAAcC,SAASsC,EACvBF,EAAavD,MACb,EAEJ,CAOA,yBAAA0D,GAEE,MAAMC,EAAqB,CACzB3D,KAAM,EAAyB9R,oBAC/B6S,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACFnG,KAAKgU,WAAWvC,aAAatL,GAAY,EAAG,IAIvD,mBAAyByP,SAAS3R,SAASqU,GAC3C,MAAMC,EAAS,mBAAyB3C,SAASO,oBAC/C,QAAcL,SAASW,EACvB,CAAC,QAAcX,SAASQ,QAE1B,mBAAyBV,SAASC,cAChC0C,EACAD,EAAmB3D,KAEvB,CAOA,0BAAA6D,GAEE,MAAMC,EAAsB,CAC1B9D,KAAM,EAAyB7R,qBAC/B4S,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACFnG,KAAKgU,WAAWvC,aAAatL,EAAW,EAAG,IAItD,mBAAyByP,SAAS3R,SAASwU,GAC3C,MAAMC,EAAS,mBAAyB9C,SAASO,oBAC/C,QAAcL,SAASkB,EACvB,CAAC,QAAclB,SAASQ,QAE1B,mBAAyBV,SAASC,cAChC6C,EACAD,EAAoB9D,KAExB,CAOA,uBAAAgE,GAEE,MAAMC,EAAmB,CACvBjE,KAAM,EAAyBhS,kBAC/B+S,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACFnG,KAAKgU,WAAWvC,aAAatL,EAAW,GAAI,IAIvD,mBAAyByP,SAAS3R,SAAS2U,GAC3C,MAAMC,EAAS,mBAAyBjD,SAASO,oBAC/C,QAAcL,SAASC,EACvB,CAAC,QAAcD,SAASQ,QAE1B,mBAAyBV,SAASC,cAChCgD,EACAD,EAAiBjE,KAErB,CAOA,yBAAAmE,GAEE,MAAMC,EAAqB,CACzBpE,KAAM,EAAyB/R,oBAC/B8S,eAAiBvP,GAEbA,EAAU8B,4BAA8B9B,EAAUgR,QAAQC,SAG9DzB,SAAWxP,GACFnG,KAAKgU,WAAWvC,aAAatL,EAAW,EAAG,IAItD,mBAAyByP,SAAS3R,SAAS8U,GAC3C,MAAMF,EAAS,mBAAyBjD,SAASO,oBAC/C,QAAcL,SAASc,EACvB,CAAC,QAAcd,SAASQ,QAE1B,mBAAyBV,SAASC,cAChCgD,EACAE,EAAmBpE,KAEvB,CAMA,YAAAqE,GAEE,MAAMC,EAAe,CACnBtE,KAAM,EAAyBpS,KAC/BmT,eAAiBvP,IACf,GACEA,EAAU8B,4BACT9B,EAAUgR,QAAQC,SACnB,CACA,MAAM7T,EAAU4C,EAAUW,YAAYtD,aACtC,GAAID,GAAWA,EAAQmG,iBAAkB,CACvC,MAAMO,EAAc1G,EAAQmG,iBAC5B,OACG,UAAgBwP,cACjBjP,GACAA,EAAYkP,eACZlP,EAAYmP,WAEhB,CACF,CACA,OAAO,CAAK,EAEdzD,SAAWxP,IACT,MAAM8D,EACJ9D,EAAUW,YAAYtD,aAAakG,iBAKrC,OAHAvD,EAAU2F,YACV9L,KAAKmS,SAAWlI,EAAYoP,aAC5BrZ,KAAK8T,cAAgB7J,EAAY9D,YACxBnG,KAAKmS,QAAQ,GAI1B,mBAAyByD,SAAS3R,SAASgV,GAE3C,MAAMK,EAAQ,mBAAyB1D,SAASO,oBAC9C,QAAcL,SAASyD,EACvB,CAAC,QAAczD,SAASO,OAE1B,mBAAyBT,SAASC,cAChCyD,EACAL,EAAatE,MACb,GAGF,MAAM6E,EAAO,mBAAyB5D,SAASO,oBAC7C,QAAcL,SAASyD,EACvB,CAAC,QAAczD,SAAS2D,MAE1B,mBAAyB7D,SAASC,cAChC2D,EACAP,EAAatE,MACb,GAGF,MAAM+E,EAAQ,mBAAyB9D,SAASO,oBAC9C,QAAcL,SAASyD,EACvB,CAAC,QAAczD,SAAS6D,OAE1B,mBAAyB/D,SAASC,cAChC6D,EACAT,EAAatE,MACb,EAEJ,CAMA,aAAAiF,GAEE,MAAMC,EAAgB,CACpBlF,KAAM,EAAyBlS,MAC/BiT,eAAiBvP,GAEbA,EAAU8B,4BACT9B,EAAUgR,QAAQC,WAClB,UAAgB8B,aAGrBvD,SAAU,OACH3V,KAAKmS,WAAanS,KAAK8T,gBACrB9T,KAAKgU,WAAW9B,MAAMlS,KAAKmS,SAAUnS,KAAK8T,gBAIrD,mBAAyB8B,SAAS3R,SAAS4V,GAE3C,MAAMC,EAAQ,mBAAyBlE,SAASO,oBAC9C,QAAcL,SAASiE,EACvB,CAAC,QAAcjE,SAASO,OAE1B,mBAAyBT,SAASC,cAChCiE,EACAD,EAAclF,MACd,GAGF,MAAMqF,EAAO,mBAAyBpE,SAASO,oBAC7C,QAAcL,SAASiE,EACvB,CAAC,QAAcjE,SAAS2D,MAE1B,mBAAyB7D,SAASC,cAChCmE,EACAH,EAAclF,MACd,GAGF,MAAMsF,EAAQ,mBAAyBrE,SAASO,oBAC9C,QAAcL,SAASiE,EACvB,CAAC,QAAcjE,SAAS6D,OAE1B,mBAAyB/D,SAASC,cAChCoE,EACAJ,EAAclF,MACd,EAEJ,CAOA,WAAAuF,GAEE,MAAMC,EAAc,CAClBxF,KAAM,EAAyBnS,IAC/BkT,eAAiBvP,IACf,GACEA,EAAU8B,4BACT9B,EAAUgR,QAAQC,SACnB,CACA,MAAM7T,EAAU4C,EAAUW,YAAYtD,aACtC,GAAID,GAAWA,EAAQmG,iBAAkB,CACvC,MAAMO,EAAc1G,EAAQmG,iBAC5B,OACG,UAAgBwP,cACjBjP,GACAA,EAAYkP,eACZlP,EAAYmP,cACXnP,EAAY9D,UAAUiU,QAE3B,CACF,CACA,OAAO,CAAK,EAEdzE,SAAWxP,IACT,MAAM8D,EACJ9D,EAAUW,YAAYtD,aAAakG,iBAMrC,OAJA1J,KAAKmS,SAAWlI,EAAYoP,aAC5BrZ,KAAK8T,cAAgB7J,EAAY9D,UACjCnG,KAAKgU,WAAWzJ,wBAAwBpE,EAAW8D,GACnDA,EAAYoQ,kBACL,CAAI,GAIf,mBAAyBzE,SAAS3R,SAASkW,GAE3C,MAAMG,EAAQ,mBAAyB1E,SAASO,oBAC9C,QAAcL,SAAS+B,EACvB,CAAC,QAAc/B,SAASO,OAE1B,mBAAyBT,SAASC,cAChCyE,EACAH,EAAYxF,MACZ,GAGF,MAAM4F,EAAO,mBAAyB3E,SAASO,oBAC7C,QAAcL,SAAS+B,EACvB,CAAC,QAAc/B,SAAS2D,MAE1B,mBAAyB7D,SAASC,cAChC0E,EACAJ,EAAYxF,MACZ,GAGF,MAAM6F,EAAQ,mBAAyB5E,SAASO,oBAC9C,QAAcL,SAAS+B,EACvB,CAAC,QAAc/B,SAAS6D,OAE1B,mBAAyB/D,SAASC,cAChC2E,EACAL,EAAYxF,MACZ,EAEJ,CAOA,cAAA8F,GAEE,MAAMC,EAAiB,CACrB/F,KAAM,EAAyBjS,OAC/BgT,eAAgB,SAAUvP,GACxB,GACEA,EAAU8B,4BACT9B,EAAUgR,QAAQC,SACnB,CACA,MAAM7T,EAAU4C,EAAUW,YAAYtD,aACtC,GAAID,GAAWA,EAAQmG,iBAAkB,CACvC,MAAMO,EAAc1G,EAAQmG,iBAC5B,OAAOO,GAAeA,EAAYkP,aACpC,CACF,CACA,OAAO,CACT,EACAxD,SAAU,CAACxP,EAAW2B,KACpB,MAAMmC,EAAc9D,EAAUW,YAAYtD,aAAakG,iBAOvD,OAFA5B,EAAE6S,kBAEE,UAAgBzB,eAGpBlZ,KAAKgU,WAAWzJ,wBAAwBpE,EAAW8D,GACnDA,EAAYoQ,kBACL,EAAI,GAGf,mBAAyBzE,SAAS3R,SAASyW,GAC3C,mBAAyB9E,SAASC,cAChC,QAAcC,SAASpT,OACvBgY,EAAe/F,MACf,GAEF,mBAAyBiB,SAASC,cAChC,QAAcC,SAAS8E,UACvBF,EAAe/F,MACf,EAEJ,CAOA,gBAAAR,GACEnU,KAAKwV,mBACLxV,KAAK0W,eACL1W,KAAK6W,aACL7W,KAAKuW,cAELvW,KAAK2X,qBACL3X,KAAKiY,eACLjY,KAAKiX,iBACLjX,KAAKsX,eACLtX,KAAK8X,uBACL9X,KAAKgW,4BAELhW,KAAK8Y,4BACL9Y,KAAKqY,4BACLrY,KAAK2Y,0BACL3Y,KAAKwY,6BAELxY,KAAKgZ,eACLhZ,KAAK4Z,gBACL5Z,KAAKka,cACLla,KAAKya,gBACP,CAMA,OAAA5H,GACE,MAAMgI,EAAgBja,OAAOka,OAAO,GACpC,IAAK,MAAMnG,KAAQkG,EACjB,mBAAyBjF,SAASmF,WAAWpG,GAE/C3U,KAAKwU,yBACLxU,KAAKgU,WAAWnB,SAClB","sources":["webpack://@blockly/keyboard-navigation/webpack/universalModuleDefinition","webpack://@blockly/keyboard-navigation/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/keyboard-navigation/webpack/bootstrap","webpack://@blockly/keyboard-navigation/webpack/runtime/define property getters","webpack://@blockly/keyboard-navigation/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/keyboard-navigation/webpack/runtime/make namespace object","webpack://@blockly/keyboard-navigation/./src/constants.js","webpack://@blockly/keyboard-navigation/./src/flyout_cursor.js","webpack://@blockly/keyboard-navigation/./src/line_cursor.js","webpack://@blockly/keyboard-navigation/./src/navigation.js","webpack://@blockly/keyboard-navigation/./src/gesture_monkey_patch.js","webpack://@blockly/keyboard-navigation/./src/navigation_controller.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Constants for keyboard navigation.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\n/**\n * Keyboard navigation states.\n * The different parts of Blockly that the user navigates between.\n * @enum {string}\n * @const\n * @public\n */\nexport const STATE = {\n  WORKSPACE: 'workspace',\n  FLYOUT: 'flyout',\n  TOOLBOX: 'toolbox',\n};\n\n/**\n * Default keyboard navigation shortcut names.\n * @enum {string}\n * @const\n * @public\n */\nexport const SHORTCUT_NAMES = {\n  PREVIOUS: 'previous',\n  NEXT: 'next',\n  IN: 'in',\n  OUT: 'out',\n  INSERT: 'insert',\n  MARK: 'mark',\n  DISCONNECT: 'disconnect',\n  TOOLBOX: 'toolbox',\n  EXIT: 'exit',\n  TOGGLE_KEYBOARD_NAV: 'toggle_keyboard_nav',\n  COPY: 'keyboard_nav_copy',\n  CUT: 'keyboard_nav_cut',\n  PASTE: 'keyboard_nav_paste',\n  DELETE: 'keyboard_nav_delete',\n  MOVE_WS_CURSOR_UP: 'workspace_up',\n  MOVE_WS_CURSOR_DOWN: 'workspace_down',\n  MOVE_WS_CURSOR_LEFT: 'workspace_left',\n  MOVE_WS_CURSOR_RIGHT: 'workspace_right',\n};\n\n/**\n * Types of possible messages passed into the loggingCallback in the Navigation\n * class.\n * @enum {string}\n * @const\n * @public\n */\nexport const LOGGING_MSG_TYPE = {\n  ERROR: 'error',\n  WARN: 'warn',\n  LOG: 'log',\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor used to navigate the flyout.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a flyout cursor.\n * This controls how a user navigates blocks in the flyout.\n * This cursor only allows a user to go to the previous or next stack.\n * @constructor\n * @extends {Blockly.Cursor}\n */\nexport class FlyoutCursor extends Blockly.Cursor {\n  /**\n   * The constructor for the FlyoutCursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next stack of blocks in the flyout.\n   * @returns {Blockly.ASTNode} The next element, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.next();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a no-op since a flyout cursor can not go in.\n   * @returns {null} Always null.\n   * @override\n   */\n  in() {\n    return null;\n  }\n\n  /**\n   * Moves the cursor to the previous stack of blocks in the flyout.\n   * @returns {Blockly.ASTNode} The previous element, or null if the current\n   *     node is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.prev();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a  no-op since a flyout cursor can not go out.\n   * @returns {null} Always null.\n   * @override\n   */\n  out() {\n    return null;\n  }\n}\n\nexport const registrationType = Blockly.registry.Type.CURSOR;\nexport const registrationName = 'FlyoutCursor';\n\nBlockly.registry.register(registrationType, registrationName, FlyoutCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a line cursor.\n * A line cursor tries to traverse the blocks and connections on a block as if\n * they were lines of code in a text editor. Previous and next traverse previous\n * connections, next connections and blocks, while in and out traverse input\n * connections and fields.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a line cursor.\n * @constructor\n * @extends {Blockly.BasicCursor}\n */\nexport class LineCursor extends Blockly.BasicCursor {\n  /**\n   * Constructor for a line cursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next previous connection, next connection or block\n   * in the pre order traversal. Finds the next node in the pre order traversal.\n   * @returns {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getNextNode_(curNode, this.validLineNode);\n\n    // Skip the input or next value if there is a connected block.\n    if (\n      newNode &&\n      (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n        newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n      newNode.getLocation().targetBlock()\n    ) {\n      newNode = this.getNextNode_(newNode, this.validLineNode);\n    }\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Moves the cursor to the next input connection or field\n   * in the pre order traversal.\n   * @returns {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  in() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getNextNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous next connection or previous connection in\n   * the pre order traversal.\n   * @returns {Blockly.ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getPreviousNode_(curNode, this.validLineNode);\n\n    if (\n      newNode &&\n      (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n        newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n      newNode.getLocation().targetBlock()\n    ) {\n      newNode = this.getPreviousNode_(newNode, this.validLineNode);\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous input connection or field in the pre order\n   * traversal.\n   * @returns {Blockly.ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  out() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getPreviousNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Decides if the previous and next methods should traverse the given node.\n   * The previous and next method only traverse previous connections, next\n   * connections and blocks.\n   * @param {Blockly.ASTNode} node The AST node to check.\n   * @returns {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.BLOCK) {\n      if (location.outputConnection === null) {\n        isValid = true;\n      }\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n      location.type == Blockly.NEXT_STATEMENT\n    ) {\n      isValid = true;\n    } else if (type == Blockly.ASTNode.types.NEXT) {\n      isValid = true;\n    }\n    return isValid;\n  }\n\n  /**\n   * Decides if the in and out methods should traverse the given node.\n   * The in and out method only traverse fields and input connections.\n   * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n   * @returns {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validInLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.FIELD) {\n      isValid = true;\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n      location.type == Blockly.INPUT_VALUE\n    ) {\n      isValid = true;\n    }\n    return isValid;\n  }\n}\n\nexport const registrationName = 'LineCursor';\nexport const registrationType = Blockly.registry.Type.CURSOR;\n\nBlockly.registry.register(registrationType, registrationName, LineCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Holds all methods necessary to use Blockly through the\n * keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from './constants';\nimport {\n  registrationName as cursorRegistrationName,\n  registrationType as cursorRegistrationType,\n} from './flyout_cursor';\n\n/**\n * Class that holds all methods necessary for keyboard navigation to work.\n */\nexport class Navigation {\n  /**\n   * Constructor for keyboard navigation.\n   */\n  constructor() {\n    /**\n     * Object holding the location of the cursor for each workspace.\n     * Possible locations of the cursor are: workspace, flyout or toolbox.\n     * @type {Object<string,Constants.STATE>}\n     * @protected\n     */\n    this.workspaceStates = {};\n\n    /**\n     * An optional method that allows a developer to customize how to handle\n     * logs, warnings, and errors. The first argument is one of 'log', 'warn',\n     * or 'error'. The second argument is the message.\n     * @type {?function(Constants.LOGGING_MSG_TYPE, string)}\n     * @public\n     */\n    this.loggingCallback = null;\n\n    /**\n     * The distance to move the cursor when the cursor is on the workspace.\n     * @type {number}\n     * @public\n     */\n    this.WS_MOVE_DISTANCE = 40;\n\n    /**\n     * The name of the marker to use for keyboard navigation.\n     * @type {string}\n     * @public\n     */\n    this.MARKER_NAME = 'local_marker_1';\n\n    /**\n     * The default coordinate to use when focusing on the workspace and no\n     * blocks are present. In pixel coordinates, but will be converted to\n     * workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.DEFAULT_WS_COORDINATE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * The default coordinate to use when moving the cursor to the workspace\n     * after a block has been deleted. In pixel coordinates, but will be\n     * converted to workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.WS_COORDINATE_ON_DELETE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * Wrapper for method that deals with workspace changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.wsChangeWrapper = this.workspaceChangeListener.bind(this);\n\n    /**\n     * Wrapper for method that deals with flyout changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.flyoutChangeWrapper = this.flyoutChangeListener.bind(this);\n\n    /**\n     * The list of registered workspaces.\n     * Used when removing change listeners in dispose.\n     * @type {!Array<!Blockly.WorkspaceSvg>}\n     * @protected\n     */\n    this.workspaces = [];\n  }\n\n  /**\n   * Adds all necessary change listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.workspaces.push(workspace);\n    const flyout = workspace.getFlyout();\n    workspace\n      .getMarkerManager()\n      .registerMarker(this.MARKER_NAME, new Blockly.Marker());\n    workspace.addChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.addFlyout(flyout);\n    }\n  }\n\n  /**\n   * Removes all keyboard navigation change listeners and markers.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    const workspaceIdx = this.workspaces.indexOf(workspace);\n    const flyout = workspace.getFlyout();\n\n    if (workspace.getCursor()) {\n      this.disableKeyboardAccessibility(workspace);\n    }\n\n    if (workspaceIdx > -1) {\n      this.workspaces.splice(workspaceIdx, 1);\n    }\n    if (workspace.getMarkerManager()) {\n      workspace.getMarkerManager().unregisterMarker(this.MARKER_NAME);\n    }\n    workspace.removeChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.removeFlyout(flyout);\n    }\n  }\n\n  /**\n   * Sets the state for the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to set the state on.\n   * @param {!Constants.STATE} state The navigation state.\n   * @protected\n   */\n  setState(workspace, state) {\n    this.workspaceStates[workspace.id] = state;\n  }\n\n  /**\n   * Gets the navigation state of the current workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the state of.\n   * @returns {!Constants.STATE} The state of the given workspace.\n   * @package\n   */\n  getState(workspace) {\n    return this.workspaceStates[workspace.id];\n  }\n\n  /**\n   * Gets the marker created for keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the marker\n   *     from.\n   * @returns {?Blockly.Marker} The marker created for keyboard navigation.\n   * @protected\n   */\n  getMarker(workspace) {\n    return workspace.getMarker(this.MARKER_NAME);\n  }\n\n  /**\n   * Adds all event listeners and cursors to the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and change\n   *     listeners to.\n   * @protected\n   */\n  addFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.addChangeListener(this.flyoutChangeWrapper);\n    const FlyoutCursorClass = Blockly.registry.getClass(\n      cursorRegistrationType,\n      cursorRegistrationName,\n    );\n    flyoutWorkspace.getMarkerManager().setCursor(new FlyoutCursorClass());\n  }\n\n  /**\n   * Removes all change listeners from the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and event\n   *     listeners to.\n   * @protected\n   */\n  removeFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.removeChangeListener(this.flyoutChangeWrapper);\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on workspace events.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  workspaceChangeListener(e) {\n    const workspace = Blockly.Workspace.getById(e.workspaceId);\n    if (!workspace || !workspace.keyboardAccessibilityMode) {\n      return;\n    }\n    switch (e.type) {\n      case Blockly.Events.DELETE:\n        this.handleBlockDeleteByDrag(workspace, e);\n        break;\n      case Blockly.Events.BLOCK_CHANGE:\n        if (e.element === 'mutation') {\n          this.handleBlockMutation(\n            workspace,\n            /** @type {Blockly.Events.BlockChange} */ (e),\n          );\n        }\n        break;\n      case Blockly.Events.CLICK:\n        this.handleWorkspaceClick(\n          workspace,\n          /** @type {Blockly.Events.Click} */ (e),\n        );\n        break;\n      case Blockly.Events.TOOLBOX_ITEM_SELECT:\n        this.handleToolboxCategoryClick(\n          workspace,\n          /** @type {Blockly.Events.ToolboxItemSelect} */ (e),\n        );\n        break;\n      case Blockly.Events.BLOCK_CREATE:\n        this.handleBlockCreate(workspace, e);\n    }\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on events emitted from the flyout's workspace.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  flyoutChangeListener(e) {\n    const flyoutWorkspace = Blockly.Workspace.getById(e.workspaceId);\n    const mainWorkspace = flyoutWorkspace.targetWorkspace;\n    const flyout = mainWorkspace.getFlyout();\n\n    // This is called for simple toolboxes and for toolboxes that have a flyout\n    // that does not close. Autoclosing flyouts close before we need to focus\n    // the cursor on the block that was clicked.\n    if (\n      mainWorkspace &&\n      mainWorkspace.keyboardAccessibilityMode &&\n      !flyout.autoClose\n    ) {\n      if (e.type === Blockly.Events.CLICK && e.targetType === 'block') {\n        const block = flyoutWorkspace.getBlockById(e.blockId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      } else if (e.type === Blockly.Events.SELECTED) {\n        const block = flyoutWorkspace.getBlockById(e.newElementId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace if a block has been dragged from a simple\n   * toolbox. For a category toolbox this is handled in\n   * handleToolboxCategoryClick_.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockCreate(workspace, e) {\n    if (this.getState(workspace) === Constants.STATE.FLYOUT) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the block level when the block the cursor is on\n   * mutates.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.BlockChange} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockMutation(workspace, e) {\n    const mutatedBlockId = e.blockId;\n    const cursor = workspace.getCursor();\n    if (cursor) {\n      const curNode = cursor.getCurNode();\n      const block = curNode ? curNode.getSourceBlock() : null;\n      if (block && block.id === mutatedBlockId) {\n        cursor.setCurNode(Blockly.ASTNode.createBlockNode(block));\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when a user clicks on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Click} e The Blockly event to process.\n   * @protected\n   */\n  handleWorkspaceClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (workspaceState !== Constants.STATE.WORKSPACE) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the toolbox when a user clicks on a toolbox category.\n   * Moves the cursor to the workspace if theh user closes the toolbox category.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the toolbox is on.\n   * @param {!Blockly.Events.ToolboxItemSelect} e The event emitted from the\n   *     workspace.\n   * @protected\n   */\n  handleToolboxCategoryClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (e.newItem && workspaceState !== Constants.STATE.TOOLBOX) {\n      // If the toolbox category was just clicked, focus on the toolbox.\n      this.focusToolbox(workspace);\n    } else if (!e.newItem) {\n      // If the toolbox was closed, focus on the workspace.\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when its parent block is deleted by\n   * being dragged to the flyout or to the trashcan.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block was on.\n   * @param {!Blockly.Events.Delete} e The event emitted when a block is\n   *     deleted.\n   * @protected\n   */\n  handleBlockDeleteByDrag(workspace, e) {\n    const deletedBlockId = e.blockId;\n    const ids = e.ids;\n    const cursor = workspace.getCursor();\n\n    // Make sure the cursor is on a block.\n    if (\n      !cursor ||\n      !cursor.getCurNode() ||\n      !cursor.getCurNode().getSourceBlock()\n    ) {\n      return;\n    }\n\n    const curNode = cursor.getCurNode();\n    const sourceBlock = curNode.getSourceBlock();\n    if (sourceBlock.id === deletedBlockId || ids.indexOf(sourceBlock.id) > -1) {\n      cursor.setCurNode(\n        Blockly.ASTNode.createWorkspaceNode(\n          workspace,\n          this.WS_COORDINATE_ON_DELETE,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Handles when a user clicks on a block in the flyout by moving the cursor\n   * to that stack of blocks and setting the state of navigation to the flyout.\n   * @param {!Blockly.WorkspaceSvg} mainWorkspace The workspace the user clicked\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block the user clicked on.\n   * @protected\n   */\n  handleBlockClickInFlyout(mainWorkspace, block) {\n    if (!block) {\n      return;\n    }\n    if (block.isShadow()) {\n      block = /** @type {Blockly.BlockSvg}*/ (block.getParent());\n    }\n    this.getFlyoutCursor(mainWorkspace).setCurNode(\n      Blockly.ASTNode.createStackNode(block),\n    );\n    this.setState(mainWorkspace, Constants.STATE.FLYOUT);\n  }\n\n  /**\n   * Moves the cursor to the appropriate location before a block is deleted.\n   * This is used when the user deletes a block using the delete or backspace\n   * key.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block is being\n   *     deleted on.\n   * @param {!Blockly.BlockSvg} deletedBlock The block that is being deleted.\n   * @package\n   */\n  moveCursorOnBlockDelete(workspace, deletedBlock) {\n    if (!workspace || !workspace.getCursor()) {\n      return;\n    }\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const block = curNode ? curNode.getSourceBlock() : null;\n\n    if (block === deletedBlock) {\n      // If the block has a parent move the cursor to their connection point.\n      if (block.getParent()) {\n        const topConnection =\n          block.previousConnection || block.outputConnection;\n        if (topConnection) {\n          cursor.setCurNode(\n            Blockly.ASTNode.createConnectionNode(\n              topConnection.targetConnection,\n            ),\n          );\n        }\n      } else {\n        // If the block is by itself move the cursor to the workspace.\n        cursor.setCurNode(\n          Blockly.ASTNode.createWorkspaceNode(\n            block.workspace,\n            block.getRelativeToSurfaceXY(),\n          ),\n        );\n      }\n      // If the cursor is on a block whose parent is being deleted, move the\n      // cursor to the workspace.\n    } else if (block && deletedBlock.getChildren(false).indexOf(block) > -1) {\n      cursor.setCurNode(\n        Blockly.ASTNode.createWorkspaceNode(\n          block.workspace,\n          block.getRelativeToSurfaceXY(),\n        ),\n      );\n    }\n  }\n\n  /**\n   * Sets the navigation state to toolbox and selects the first category in the\n   * toolbox. No-op if a toolbox does not exist on the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the toolbox\n   *     on.\n   * @package\n   */\n  focusToolbox(workspace) {\n    const toolbox = workspace.getToolbox();\n    if (!toolbox) {\n      return;\n    }\n\n    this.setState(workspace, Constants.STATE.TOOLBOX);\n    this.resetFlyout(workspace, false /* shouldHide */);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (!toolbox.getSelectedItem()) {\n      // Find the first item that is selectable.\n      const toolboxItems = toolbox.getToolboxItems();\n      for (let i = 0, toolboxItem; (toolboxItem = toolboxItems[i]); i++) {\n        if (toolboxItem.isSelectable()) {\n          toolbox.selectItemByPosition(i);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to flyout and moves the cursor to the first\n   * block or button in the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the flyout is on.\n   * @package\n   */\n  focusFlyout(workspace) {\n    const flyout = workspace.getFlyout();\n\n    this.setState(workspace, Constants.STATE.FLYOUT);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (flyout && flyout.getWorkspace()) {\n      const flyoutContents = flyout.getContents();\n      const firstFlyoutItem = flyoutContents[0];\n      if (!firstFlyoutItem) return;\n      if (firstFlyoutItem.button) {\n        const astNode = Blockly.ASTNode.createButtonNode(\n          firstFlyoutItem.button,\n        );\n        this.getFlyoutCursor(workspace).setCurNode(astNode);\n      } else if (firstFlyoutItem.block) {\n        const astNode = Blockly.ASTNode.createStackNode(firstFlyoutItem.block);\n        this.getFlyoutCursor(workspace).setCurNode(astNode);\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to workspace and moves the cursor to either the\n   * top block on a workspace or to the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to focus on.\n   * @package\n   */\n  focusWorkspace(workspace) {\n    workspace.hideChaff();\n    const reset = !!workspace.getToolbox();\n\n    this.resetFlyout(workspace, reset);\n    this.setState(workspace, Constants.STATE.WORKSPACE);\n    this.setCursorOnWorkspaceFocus(workspace);\n  }\n\n  /**\n   * Moves the cursor to the top connection point on on the first top block.\n   * If the workspace is empty, moves the cursor to the default location on\n   * the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main Blockly workspace.\n   * @protected\n   */\n  setCursorOnWorkspaceFocus(workspace) {\n    const topBlocks = workspace.getTopBlocks(true);\n    const cursor = workspace.getCursor();\n    const wsCoordinates = new Blockly.utils.Coordinate(\n      this.DEFAULT_WS_COORDINATE.x / workspace.scale,\n      this.DEFAULT_WS_COORDINATE.y / workspace.scale,\n    );\n    if (topBlocks.length > 0) {\n      cursor.setCurNode(Blockly.ASTNode.createTopNode(topBlocks[0]));\n    } else {\n      const wsNode = Blockly.ASTNode.createWorkspaceNode(\n        workspace,\n        wsCoordinates,\n      );\n      cursor.setCurNode(wsNode);\n    }\n  }\n\n  /**\n   * Gets the cursor on the flyout's workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace the flyout is\n   *     on.\n   * @returns {?Blockly.FlyoutCursor} The flyout's cursor or null if no flyout\n   *     exists.\n   * @protected\n   */\n  getFlyoutCursor(workspace) {\n    const flyout = workspace.getFlyout();\n    const cursor = flyout ? flyout.getWorkspace().getCursor() : null;\n\n    return /** @type {?Blockly.FlyoutCursor} */ (cursor);\n  }\n\n  /**\n   * Inserts a block from the flyout.\n   * Tries to find a connection on the block to connect to the marked\n   * location. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @package\n   */\n  insertFromFlyout(workspace) {\n    const newBlock = this.createNewBlock(workspace);\n    if (!newBlock) {\n      return;\n    }\n    const markerNode = this.getMarker(workspace).getCurNode();\n    if (\n      !this.tryToConnectMarkerAndCursor(\n        workspace,\n        markerNode,\n        Blockly.ASTNode.createBlockNode(newBlock),\n      )\n    ) {\n      this.warn(\n        'Something went wrong while inserting a block from the flyout.',\n      );\n    }\n\n    this.focusWorkspace(workspace);\n    workspace.getCursor().setCurNode(Blockly.ASTNode.createTopNode(newBlock));\n    this.removeMark(workspace);\n  }\n\n  /**\n   * Creates a new block based on the current block the flyout cursor is on.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @returns {?Blockly.BlockSvg} The newly created block.\n   * @protected\n   */\n  createNewBlock(workspace) {\n    const flyout = workspace.getFlyout();\n    if (!flyout || !flyout.isVisible()) {\n      this.warn(\n        'Trying to insert from the flyout when the flyout does not ' +\n          ' exist or is not visible',\n      );\n      return null;\n    }\n\n    const curBlock = /** @type {!Blockly.BlockSvg} */ (\n      this.getFlyoutCursor(workspace).getCurNode().getLocation()\n    );\n    if (!curBlock.isEnabled()) {\n      this.warn(\"Can't insert a disabled block.\");\n      return null;\n    }\n\n    const newBlock = flyout.createBlock(curBlock);\n    // Render to get the sizing right.\n    newBlock.render();\n    // Connections are not tracked when the block is first created.  Normally\n    // there's enough time for them to become tracked in the user's mouse\n    // movements, but not here.\n    newBlock.setConnectionTracking(true);\n    return newBlock;\n  }\n\n  /**\n   * Hides the flyout cursor and optionally hides the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @param {boolean} shouldHide True if the flyout should be hidden.\n   * @protected\n   */\n  resetFlyout(workspace, shouldHide) {\n    if (this.getFlyoutCursor(workspace)) {\n      this.getFlyoutCursor(workspace).hide();\n      if (shouldHide) {\n        workspace.getFlyout().hide();\n      }\n    }\n  }\n\n  /**\n   * Connects the location of the marker and the location of the cursor.\n   * No-op if the marker or cursor node are null.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @returns {boolean} True if the cursor and marker locations were connected,\n   *     false otherwise.\n   * @package\n   */\n  connectMarkerAndCursor(workspace) {\n    const markerNode = this.getMarker(workspace).getCurNode();\n    const cursorNode = workspace.getCursor().getCurNode();\n\n    if (markerNode && cursorNode) {\n      return this.tryToConnectMarkerAndCursor(\n        workspace,\n        markerNode,\n        cursorNode,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given marker and cursor node.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @returns {boolean} True if the key was handled; false if something went\n   *     wrong.\n   * @protected\n   */\n  tryToConnectMarkerAndCursor(workspace, markerNode, cursorNode) {\n    if (!this.logConnectionWarning(markerNode, cursorNode)) {\n      return false;\n    }\n\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    const cursorLoc = cursorNode.getLocation();\n    const markerLoc = markerNode.getLocation();\n    if (markerNode.isConnection() && cursorNode.isConnection()) {\n      const cursorConnection = /** @type {!Blockly.RenderedConnection} */ (\n        cursorLoc\n      );\n      const markerConnection = /** @type {!Blockly.RenderedConnection} */ (\n        markerLoc\n      );\n      return this.connect(cursorConnection, markerConnection);\n    } else if (\n      markerNode.isConnection() &&\n      (cursorType == Blockly.ASTNode.types.BLOCK ||\n        cursorType == Blockly.ASTNode.types.STACK)\n    ) {\n      const cursorBlock = /** @type {!Blockly.BlockSvg} */ (cursorLoc);\n      const markerConnection = /** @type {!Blockly.RenderedConnection} */ (\n        markerLoc\n      );\n      return this.insertBlock(cursorBlock, markerConnection);\n    } else if (markerType == Blockly.ASTNode.types.WORKSPACE) {\n      const block = cursorNode ? cursorNode.getSourceBlock() : null;\n      return this.moveBlockToWorkspace(\n        /** @type {Blockly.BlockSvg} */ (block),\n        markerNode,\n      );\n    }\n    this.warn('Unexpected state in tryToConnectMarkerAndCursor.');\n    return false;\n  }\n\n  /**\n   * Warns the user if the given cursor or marker node can not be connected.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @returns {boolean} True if the marker and cursor are valid types, false\n   *     otherwise.\n   * @protected\n   */\n  logConnectionWarning(markerNode, cursorNode) {\n    if (!markerNode) {\n      this.warn('Cannot insert with no marked node.');\n      return false;\n    }\n\n    if (!cursorNode) {\n      this.warn('Cannot insert with no cursor node.');\n      return false;\n    }\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    // Check the marker for invalid types.\n    if (markerType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Should not have been able to mark a field.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Should not have been able to mark a block.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.STACK) {\n      this.warn('Should not have been able to mark a stack.');\n      return false;\n    }\n\n    // Check the cursor for invalid types.\n    if (cursorType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Cannot attach a field to anything else.');\n      return false;\n    } else if (cursorType == Blockly.ASTNode.types.WORKSPACE) {\n      this.warn('Cannot attach a workspace to anything else.');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Disconnects the block from its parent and moves it to the position of the\n   * workspace node.\n   * @param {?Blockly.BlockSvg} block The block to be moved to the workspace.\n   * @param {!Blockly.ASTNode} wsNode The workspace node holding the position\n   *     the block will be moved to.\n   * @returns {boolean} True if the block can be moved to the workspace,\n   *     false otherwise.\n   * @protected\n   */\n  moveBlockToWorkspace(block, wsNode) {\n    if (!block) {\n      return false;\n    }\n    if (block.isShadow()) {\n      this.warn('Cannot move a shadow block to the workspace.');\n      return false;\n    }\n    if (block.getParent()) {\n      block.unplug(false);\n    }\n    block.moveTo(wsNode.getWsCoordinate());\n    return true;\n  }\n\n  /**\n   * Disconnects the child block from its parent block. No-op if the two given\n   * connections are unrelated.\n   * @param {!Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @protected\n   */\n  disconnectChild(movingConnection, destConnection) {\n    const movingBlock = movingConnection.getSourceBlock();\n    const destBlock = destConnection.getSourceBlock();\n    let inferiorConnection;\n\n    if (movingBlock.getRootBlock() === destBlock.getRootBlock()) {\n      if (movingBlock.getDescendants(false).indexOf(destBlock) > -1) {\n        inferiorConnection = this.getInferiorConnection(destConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      } else {\n        inferiorConnection = this.getInferiorConnection(movingConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      }\n    }\n  }\n\n  /**\n   * Tries to connect the  given connections.\n   *\n   * If the given connections are not compatible try finding compatible\n   * connections on the source blocks of the given connections.\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @returns {boolean} True if the two connections or their target connections\n   *     were connected, false otherwise.\n   * @protected\n   */\n  connect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n\n    const movingInferior = this.getInferiorConnection(movingConnection);\n    const destSuperior = this.getSuperiorConnection(destConnection);\n\n    const movingSuperior = this.getSuperiorConnection(movingConnection);\n    const destInferior = this.getInferiorConnection(destConnection);\n\n    if (\n      movingInferior &&\n      destSuperior &&\n      this.moveAndConnect(movingInferior, destSuperior)\n    ) {\n      return true;\n      // Try swapping the inferior and superior connections on the blocks.\n    } else if (\n      movingSuperior &&\n      destInferior &&\n      this.moveAndConnect(movingSuperior, destInferior)\n    ) {\n      return true;\n    } else if (this.moveAndConnect(movingConnection, destConnection)) {\n      return true;\n    } else {\n      const checker = movingConnection.getConnectionChecker();\n      const reason = checker.canConnectWithReason(\n        movingConnection,\n        destConnection,\n        false,\n      );\n      this.warn(\n        'Connection failed with error: ' +\n          checker.getErrorMessage(reason, movingConnection, destConnection),\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Finds the inferior connection on the source block if the given connection\n   * is superior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @returns {?Blockly.RenderedConnection} The inferior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getInferiorConnection(connection) {\n    const block = /** @type{!Blockly.BlockSvg} */ (connection.getSourceBlock());\n    if (!connection.isSuperior()) {\n      return connection;\n    } else if (block.previousConnection) {\n      return block.previousConnection;\n    } else if (block.outputConnection) {\n      return block.outputConnection;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Finds a superior connection on the source block if the given connection is\n   * inferior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @returns {?Blockly.RenderedConnection} The superior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getSuperiorConnection(connection) {\n    if (connection.isSuperior()) {\n      return connection;\n    } else if (connection.targetConnection) {\n      return connection.targetConnection;\n    }\n    return null;\n  }\n\n  /**\n   * Moves the moving connection to the target connection and connects them.\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @returns {boolean} True if the connections were connected, false otherwise.\n   * @protected\n   */\n  moveAndConnect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n    const movingBlock = movingConnection.getSourceBlock();\n    const checker = movingConnection.getConnectionChecker();\n\n    if (\n      checker.canConnect(movingConnection, destConnection, false) &&\n      !destConnection.getSourceBlock().isShadow()\n    ) {\n      this.disconnectChild(movingConnection, destConnection);\n\n      // Position the root block near the connection so it does not move the\n      // other block when they are connected.\n      if (!destConnection.isSuperior()) {\n        const rootBlock = movingBlock.getRootBlock();\n\n        const originalOffsetToTarget = {\n          x: destConnection.x - movingConnection.x,\n          y: destConnection.y - movingConnection.y,\n        };\n        const originalOffsetInBlock = movingConnection\n          .getOffsetInBlock()\n          .clone();\n        rootBlock.positionNearConnection(\n          movingConnection,\n          originalOffsetToTarget,\n          originalOffsetInBlock,\n        );\n      }\n      destConnection.connect(movingConnection);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given block to the destination connection, making an\n   * intelligent guess about which connection to use on the moving block.\n   * @param {!Blockly.BlockSvg} block The block to move.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to\n   *     connect to.\n   * @returns {boolean} Whether the connection was successful.\n   * @protected\n   */\n  insertBlock(block, destConnection) {\n    switch (destConnection.type) {\n      case Blockly.PREVIOUS_STATEMENT:\n        if (this.connect(block.nextConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.NEXT_STATEMENT:\n        if (this.connect(block.previousConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.INPUT_VALUE:\n        if (this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.OUTPUT_VALUE:\n        for (let i = 0; i < block.inputList.length; i++) {\n          const inputConnection = /** @type {Blockly.RenderedConnection} */ (\n            block.inputList[i].connection\n          );\n          if (\n            inputConnection &&\n            inputConnection.type === Blockly.INPUT_VALUE &&\n            this.connect(inputConnection, destConnection)\n          ) {\n            return true;\n          }\n        }\n        // If there are no input values pass the output and destination\n        // connections to connect_ to find a way to connect the two.\n        if (\n          block.outputConnection &&\n          this.connect(block.outputConnection, destConnection)\n        ) {\n          return true;\n        }\n        break;\n    }\n    this.warn('This block can not be inserted at the marked location.');\n    return false;\n  }\n\n  /**\n   * Disconnects the connection that the cursor is pointing to, and bump blocks.\n   * This is a no-op if the connection cannot be broken or if the cursor is not\n   * pointing to a connection.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  disconnectBlocks(workspace) {\n    const curNode = workspace.getCursor().getCurNode();\n    if (!curNode.isConnection()) {\n      this.log(\n        'Cannot disconnect blocks when the cursor is not on a connection',\n      );\n      return;\n    }\n    const curConnection = /** @type {!Blockly.RenderedConnection} */ (\n      curNode.getLocation()\n    );\n    if (!curConnection.isConnected()) {\n      this.log('Cannot disconnect unconnected connection');\n      return;\n    }\n    const superiorConnection = curConnection.isSuperior()\n      ? curConnection\n      : curConnection.targetConnection;\n\n    const inferiorConnection = curConnection.isSuperior()\n      ? curConnection.targetConnection\n      : curConnection;\n\n    if (inferiorConnection.getSourceBlock().isShadow()) {\n      this.log('Cannot disconnect a shadow block');\n      return;\n    }\n    superiorConnection.disconnect();\n    inferiorConnection.bumpAwayFrom(superiorConnection);\n\n    const rootBlock = superiorConnection.getSourceBlock().getRootBlock();\n    rootBlock.bringToFront();\n\n    const connectionNode =\n      Blockly.ASTNode.createConnectionNode(superiorConnection);\n    workspace.getCursor().setCurNode(connectionNode);\n  }\n\n  /**\n   * Moves the marker to the cursor's current location.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  markAtCursor(workspace) {\n    this.getMarker(workspace).setCurNode(workspace.getCursor().getCurNode());\n  }\n\n  /**\n   * Removes the marker from its current location and hide it.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  removeMark(workspace) {\n    const marker = this.getMarker(workspace);\n    marker.setCurNode(null);\n    marker.hide();\n  }\n\n  /**\n   * Enables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to enable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  enableKeyboardAccessibility(workspace) {\n    if (\n      this.workspaces.indexOf(workspace) > -1 &&\n      !workspace.keyboardAccessibilityMode\n    ) {\n      workspace.keyboardAccessibilityMode = true;\n      this.focusWorkspace(workspace);\n    }\n  }\n\n  /**\n   * Disables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to disable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  disableKeyboardAccessibility(workspace) {\n    if (\n      this.workspaces.indexOf(workspace) > -1 &&\n      workspace.keyboardAccessibilityMode\n    ) {\n      workspace.keyboardAccessibilityMode = false;\n      workspace.getCursor().hide();\n      this.getMarker(workspace).hide();\n      if (this.getFlyoutCursor(workspace)) {\n        this.getFlyoutCursor(workspace).hide();\n      }\n    }\n  }\n\n  /**\n   * Navigation log handler. If loggingCallback is defined, use it.\n   * Otherwise just log to the console.log.\n   * @param {string} msg The message to log.\n   * @protected\n   */\n  log(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.LOG, msg);\n    } else {\n      console.log(msg);\n    }\n  }\n\n  /**\n   * Navigation warning handler. If loggingCallback is defined, use it.\n   * Otherwise call console.warn.\n   * @param {string} msg The warning message.\n   * @protected\n   */\n  warn(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.WARN, msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Navigation error handler. If loggingCallback is defined, use it.\n   * Otherwise call console.error.\n   * @param {string} msg The error message.\n   * @protected\n   */\n  error(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.ERROR, msg);\n    } else {\n      console.error(msg);\n    }\n  }\n\n  /**\n   * Moves the workspace cursor in the given direction.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor is on.\n   * @param {number} xDirection -1 to move cursor left. 1 to move cursor right.\n   * @param {number} yDirection -1 to move cursor up. 1 to move cursor down.\n   * @returns {boolean} True if the current node is a workspace, false\n   *     otherwise.\n   * @package\n   */\n  moveWSCursor(workspace, xDirection, yDirection) {\n    const cursor = workspace.getCursor();\n    const curNode = workspace.getCursor().getCurNode();\n\n    if (curNode.getType() !== Blockly.ASTNode.types.WORKSPACE) {\n      return false;\n    }\n\n    const wsCoord = curNode.getWsCoordinate();\n    const newX = xDirection * this.WS_MOVE_DISTANCE + wsCoord.x;\n    const newY = yDirection * this.WS_MOVE_DISTANCE + wsCoord.y;\n\n    cursor.setCurNode(\n      Blockly.ASTNode.createWorkspaceNode(\n        workspace,\n        new Blockly.utils.Coordinate(newX, newY),\n      ),\n    );\n    return true;\n  }\n\n  /**\n   * Handles hitting the enter key on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  handleEnterForWS(workspace) {\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const nodeType = curNode.getType();\n    if (nodeType == Blockly.ASTNode.types.FIELD) {\n      /** @type {!Blockly.Field} */ (curNode.getLocation()).showEditor();\n    } else if (\n      curNode.isConnection() ||\n      nodeType == Blockly.ASTNode.types.WORKSPACE\n    ) {\n      this.markAtCursor(workspace);\n    } else if (nodeType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Cannot mark a block.');\n    } else if (nodeType == Blockly.ASTNode.types.STACK) {\n      this.warn('Cannot mark a stack.');\n    }\n  }\n\n  /**\n   * Pastes the copied block to the marked location.\n   * @param {Blockly.BlockCopyData} copyData The data\n   *     to paste into the workspace.\n   * @param {Blockly.WorkspaceSvg} workspace The workspace to paste the data\n   *     into.\n   * @returns {boolean} True if the paste was sucessful, false otherwise.\n   * @package\n   */\n  paste(copyData, workspace) {\n    let isHandled = false;\n    Blockly.Events.setGroup(true);\n    const block = /** @type {Blockly.BlockSvg} */ (\n      Blockly.clipboard.paste(copyData, workspace)\n    );\n    if (block) {\n      isHandled = this.insertPastedBlock(workspace, block);\n    }\n    Blockly.Events.setGroup(false);\n    return isHandled;\n  }\n\n  /**\n   * Inserts the pasted block at the marked location if a compatible connection\n   * exists. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to paste the block\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block to paste.\n   * @returns {boolean} True if the block was pasted to the workspace, false\n   *     otherwise.\n   * @protected\n   */\n  insertPastedBlock(workspace, block) {\n    let isHandled = false;\n    const markedNode = workspace.getMarker(this.MARKER_NAME).getCurNode();\n    if (markedNode) {\n      isHandled = this.tryToConnectMarkerAndCursor(\n        workspace,\n        markedNode,\n        Blockly.ASTNode.createBlockNode(block),\n      );\n    }\n    return isHandled;\n  }\n\n  /**\n   * Triggers a flyout button's callback.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     containing a flyout with a button.\n   * @package\n   */\n  triggerButtonCallback(workspace) {\n    const button = /** @type {!Blockly.FlyoutButton} */ (\n      this.getFlyoutCursor(workspace).getCurNode().getLocation()\n    );\n    const buttonCallback = workspace.flyoutButtonCallbacks.get(\n      button.callbackKey,\n    );\n    if (typeof buttonCallback === 'function') {\n      buttonCallback(button);\n    } else {\n      throw new Error('No callback function found for flyout button.');\n    }\n  }\n\n  /**\n   * Removes the change listeners on all registered workspaces.\n   * @package\n   */\n  dispose() {\n    for (const workspace of this.workspaces) {\n      this.removeWorkspace(workspace);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides methods on Blockly.Gesture in order to allow users\n * to move the cursor to blocks or the workspace using shift click.\n * TODO(google/blockly#4584): We do not have a way to do this currently without\n * monkey patching Blockly.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\nconst oldDoWorkspaceClick = Blockly.Gesture.prototype.doWorkspaceClick_;\n\n/**\n * Execute a workspace click. When in accessibility mode shift clicking will\n * move the cursor.\n * @param {!Event} e A mouse up or touch end event.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doWorkspaceClick_ = function (e) {\n  oldDoWorkspaceClick.call(this, e);\n  const ws = this.creatorWorkspace_;\n  if (e.shiftKey && ws.keyboardAccessibilityMode) {\n    const screenCoord = new Blockly.utils.Coordinate(e.clientX, e.clientY);\n    const wsCoord = Blockly.utils.svgMath.screenToWsCoordinates(\n      ws,\n      screenCoord,\n    );\n    const wsNode = Blockly.ASTNode.createWorkspaceNode(ws, wsCoord);\n    ws.getCursor().setCurNode(wsNode);\n  }\n};\n\nconst oldDoBlockClick = Blockly.Gesture.prototype.doBlockClick_;\n\n/**\n * Execute a block click. When in accessibility mode shift clicking will move\n * the cursor to the block.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doBlockClick_ = function (e) {\n  oldDoBlockClick.call(this, e);\n  if (\n    !this.targetBlock_.isInFlyout &&\n    this.mostRecentEvent_.shiftKey &&\n    this.targetBlock_.workspace.keyboardAccessibilityMode\n  ) {\n    this.creatorWorkspace_\n      .getCursor()\n      .setCurNode(Blockly.ASTNode.createTopNode(this.targetBlock_));\n  }\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers all of the keyboard shortcuts that are necessary for\n * navigating blockly using the keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport './gesture_monkey_patch';\n\nimport * as Blockly from 'blockly/core';\n\nimport * as Constants from './constants';\nimport {Navigation} from './navigation';\n\n/**\n * Class for registering shortcuts for keyboard navigation.\n */\nexport class NavigationController {\n  /** Data copied by the copy or cut keyboard shortcuts. */\n  copyData = null;\n\n  /** The workspace a copy or cut keyboard shortcut happened in. */\n  copyWorkspace = null;\n\n  /**\n   * Constructor used for registering shortcuts.\n   * This will register any default shortcuts for keyboard navigation.\n   * This is intended to be a singleton.\n   * @param {!Navigation=} optNavigation The class that handles keyboard\n   *     navigation shortcuts. (Ex: inserting a block, focusing the flyout).\n   */\n  constructor(optNavigation) {\n    /**\n     * Handles any keyboard navigation shortcuts.\n     * @type {!Navigation}\n     * @public\n     */\n    this.navigation = optNavigation || new Navigation();\n  }\n\n  /**\n   * Registers the default keyboard shortcuts for keyboard navigation.\n   * @public\n   */\n  init() {\n    this.addShortcutHandlers();\n    this.registerDefaults();\n  }\n\n  /**\n   * Adds methods to core Blockly components that allows them to handle keyboard\n   * shortcuts when in keyboard navigation mode.\n   * @protected\n   */\n  addShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = this.fieldColourHandler;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = this.fieldDropdownHandler;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = this.toolboxHandler;\n    }\n  }\n\n  /**\n   * Removes methods on core Blockly components that allows them to handle\n   * keyboard shortcuts.\n   * @protected\n   */\n  removeShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = null;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = null;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = null;\n    }\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @returns {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldColour}\n   * @protected\n   */\n  fieldColourHandler(shortcut) {\n    if (this.picker_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.moveHighlightBy_(0, -1);\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.moveHighlightBy_(0, 1);\n          return true;\n        case Constants.SHORTCUT_NAMES.OUT:\n          this.moveHighlightBy_(-1, 0);\n          return true;\n        case Constants.SHORTCUT_NAMES.IN:\n          this.moveHighlightBy_(1, 0);\n          return true;\n        default:\n          return false;\n      }\n    }\n    // If we haven't already handled the shortcut, let the default Field\n    // handler try.\n    return Blockly.Field.prototype.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @returns {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldDropdown}\n   * @protected\n   */\n  fieldDropdownHandler(shortcut) {\n    if (this.menu_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.menu_.highlightPrevious();\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.menu_.highlightNext();\n          return true;\n        default:\n          return false;\n      }\n    }\n    // If we haven't already handled the shortcut, let the default Field\n    // handler try.\n    return Blockly.Field.prototype.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @returns {boolean} True if the toolbox handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.Toolbox}\n   * @protected\n   */\n  toolboxHandler(shortcut) {\n    if (!this.selectedItem_) {\n      return false;\n    }\n    switch (shortcut.name) {\n      case Constants.SHORTCUT_NAMES.PREVIOUS:\n        return this.selectPrevious_();\n      case Constants.SHORTCUT_NAMES.OUT:\n        return this.selectParent_();\n      case Constants.SHORTCUT_NAMES.NEXT:\n        return this.selectNext_();\n      case Constants.SHORTCUT_NAMES.IN:\n        return this.selectChild_();\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Adds all necessary event listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.navigation.addWorkspace(workspace);\n  }\n\n  /**\n   * Removes all necessary event listeners and markers to a workspace for\n   * keyboard navigation to work.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    this.navigation.removeWorkspace(workspace);\n  }\n\n  /**\n   * Turns on keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn on keyboard\n   *     navigation for.\n   * @public\n   */\n  enable(workspace) {\n    this.navigation.enableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Turns off keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn off keyboard\n   *     navigation on.\n   * @public\n   */\n  disable(workspace) {\n    this.navigation.disableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Gives the cursor to the field to handle if the cursor is on a field.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to check.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to give to the field.\n   * @returns {boolean} True if the shortcut was handled by the field, false\n   *     otherwise.\n   * @protected\n   */\n  fieldShortcutHandler(workspace, shortcut) {\n    const cursor = workspace.getCursor();\n    if (!cursor || !cursor.getCurNode()) {\n      return false;\n    }\n    const curNode = cursor.getCurNode();\n    if (curNode.getType() === Blockly.ASTNode.types.FIELD) {\n      return /** @type {!Blockly.Field} */ (curNode.getLocation()).onShortcut(\n        shortcut,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Keyboard shortcut to go to the previous location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerPrevious() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const previousShortcut = {\n      name: Constants.SHORTCUT_NAMES.PREVIOUS,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const flyout = workspace.getFlyout();\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function'\n              ? toolbox.onShortcut(shortcut)\n              : false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(previousShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.W,\n      previousShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to turn keyboard navigation on or off.\n   * @protected\n   */\n  registerToggleKeyboardNav() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const toggleKeyboardNavShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOGGLE_KEYBOARD_NAV,\n      callback: (workspace) => {\n        if (workspace.keyboardAccessibilityMode) {\n          this.navigation.disableKeyboardAccessibility(workspace);\n        } else {\n          this.navigation.enableKeyboardAccessibility(workspace);\n        }\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(toggleKeyboardNavShortcut);\n    const ctrlShiftK = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.K,\n      [Blockly.utils.KeyCodes.CTRL, Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlShiftK,\n      toggleKeyboardNavShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to go to the out location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerOut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const outShortcut = {\n      name: Constants.SHORTCUT_NAMES.OUT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().out();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusToolbox(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function'\n              ? toolbox.onShortcut(shortcut)\n              : false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(outShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.A,\n      outShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to go to the next location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerNext() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const nextShortcut = {\n      name: Constants.SHORTCUT_NAMES.NEXT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        const flyout = workspace.getFlyout();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function'\n              ? toolbox.onShortcut(shortcut)\n              : false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(nextShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.S,\n      nextShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to go to the in location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerIn() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const inShortcut = {\n      name: Constants.SHORTCUT_NAMES.IN,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().in();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            isHandled =\n              toolbox && typeof toolbox.onShortcut == 'function'\n                ? toolbox.onShortcut(shortcut)\n                : false;\n            if (!isHandled) {\n              this.navigation.focusFlyout(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(inShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.D,\n      inShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to connect a block to a marked location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerInsert() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const insertShortcut = {\n      name: Constants.SHORTCUT_NAMES.INSERT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            return this.navigation.connectMarkerAndCursor(workspace);\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(insertShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.I,\n      insertShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to mark a location when in keyboard navigation mode.\n   * @protected\n   */\n  registerMark() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const markShortcut = {\n      name: Constants.SHORTCUT_NAMES.MARK,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        let flyoutCursor;\n        let curNode;\n        let nodeType;\n\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.handleEnterForWS(workspace);\n            return true;\n          case Constants.STATE.FLYOUT:\n            flyoutCursor = this.navigation.getFlyoutCursor(workspace);\n            if (!flyoutCursor) {\n              return false;\n            }\n            curNode = flyoutCursor.getCurNode();\n            nodeType = curNode.getType();\n\n            switch (nodeType) {\n              case Blockly.ASTNode.types.STACK:\n                this.navigation.insertFromFlyout(workspace);\n                break;\n              case Blockly.ASTNode.types.BUTTON:\n                this.navigation.triggerButtonCallback(workspace);\n                break;\n            }\n\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(markShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.ENTER,\n      markShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to disconnect two blocks when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerDisconnect() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const disconnectShortcut = {\n      name: Constants.SHORTCUT_NAMES.DISCONNECT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.disconnectBlocks(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(disconnectShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.X,\n      disconnectShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to focus on the toolbox when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerToolboxFocus() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const focusToolboxShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOOLBOX,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            if (!workspace.getToolbox()) {\n              this.navigation.focusFlyout(workspace);\n            } else {\n              this.navigation.focusToolbox(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(focusToolboxShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.T,\n      focusToolboxShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to exit the current location and focus on the workspace\n   * when in keyboard navigation mode.\n   * @protected\n   */\n  registerExit() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const exitShortcut = {\n      name: Constants.SHORTCUT_NAMES.EXIT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(exitShortcut, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.ESC,\n      exitShortcut.name,\n      true,\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.E,\n      exitShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the left when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveLeft() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveLeftShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_LEFT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, -1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveLeftShortcut);\n    const shiftA = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.A,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftA,\n      wsMoveLeftShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the right when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveRight() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveRightShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_RIGHT,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveRightShortcut);\n    const shiftD = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.D,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftD,\n      wsMoveRightShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace up when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveUp() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveUpShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_UP,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, -1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveUpShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.W,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftW,\n      wsMoveUpShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace down when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveDown() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveDownShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_DOWN,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode && !workspace.options.readOnly\n        );\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, 1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveDownShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.S,\n      [Blockly.utils.KeyCodes.SHIFT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      shiftW,\n      wsMoveDownShortcut.name,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to copy the block the cursor is currently on.\n   * @protected\n   */\n  registerCopy() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const copyShortcut = {\n      name: Constants.SHORTCUT_NAMES.COPY,\n      preconditionFn: (workspace) => {\n        if (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly\n        ) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return (\n              !Blockly.Gesture.inProgress() &&\n              sourceBlock &&\n              sourceBlock.isDeletable() &&\n              sourceBlock.isMovable()\n            );\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = /** @type {Blockly.BlockSvg} */ (\n          workspace.getCursor().getCurNode().getSourceBlock()\n        );\n        workspace.hideChaff();\n        this.copyData = sourceBlock.toCopyData();\n        this.copyWorkspace = sourceBlock.workspace;\n        return !!this.copyData;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(copyShortcut);\n\n    const ctrlC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlC,\n      copyShortcut.name,\n      true,\n    );\n\n    const altC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.ALT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      altC,\n      copyShortcut.name,\n      true,\n    );\n\n    const metaC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.C,\n      [Blockly.utils.KeyCodes.META],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      metaC,\n      copyShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Register shortcut to paste the copied block to the marked location.\n   * @protected\n   */\n  registerPaste() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const pasteShortcut = {\n      name: Constants.SHORTCUT_NAMES.PASTE,\n      preconditionFn: (workspace) => {\n        return (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly &&\n          !Blockly.Gesture.inProgress()\n        );\n      },\n      callback: () => {\n        if (!this.copyData || !this.copyWorkspace) return false;\n        return this.navigation.paste(this.copyData, this.copyWorkspace);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(pasteShortcut);\n\n    const ctrlV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlV,\n      pasteShortcut.name,\n      true,\n    );\n\n    const altV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.ALT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      altV,\n      pasteShortcut.name,\n      true,\n    );\n\n    const metaV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.V,\n      [Blockly.utils.KeyCodes.META],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      metaV,\n      pasteShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Keyboard shortcut to copy and delete the block the cursor is on using\n   * ctrl+x, cmd+x, or alt+x.\n   * @protected\n   */\n  registerCut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const cutShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n      preconditionFn: (workspace) => {\n        if (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly\n        ) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return (\n              !Blockly.Gesture.inProgress() &&\n              sourceBlock &&\n              sourceBlock.isDeletable() &&\n              sourceBlock.isMovable() &&\n              !sourceBlock.workspace.isFlyout\n            );\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = /** @type {Blockly.BlockSvg} */ (\n          workspace.getCursor().getCurNode().getSourceBlock()\n        );\n        this.copyData = sourceBlock.toCopyData();\n        this.copyWorkspace = sourceBlock.workspace;\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        sourceBlock.checkAndDelete();\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(cutShortcut);\n\n    const ctrlX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.CTRL],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      ctrlX,\n      cutShortcut.name,\n      true,\n    );\n\n    const altX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.ALT],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      altX,\n      cutShortcut.name,\n      true,\n    );\n\n    const metaX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n      Blockly.utils.KeyCodes.X,\n      [Blockly.utils.KeyCodes.META],\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      metaX,\n      cutShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Registers shortcut to delete the block the cursor is on using delete or\n   * backspace.\n   * @protected\n   */\n  registerDelete() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const deleteShortcut = {\n      name: Constants.SHORTCUT_NAMES.DELETE,\n      preconditionFn: function (workspace) {\n        if (\n          workspace.keyboardAccessibilityMode &&\n          !workspace.options.readOnly\n        ) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return sourceBlock && sourceBlock.isDeletable();\n          }\n        }\n        return false;\n      },\n      callback: (workspace, e) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        // Delete or backspace.\n        // Stop the browser from going back to the previous page.\n        // Do this first to prevent an error in the delete code from resulting\n        // in data loss.\n        e.preventDefault();\n        // Don't delete while dragging.  Jeez.\n        if (Blockly.Gesture.inProgress()) {\n          return false;\n        }\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        sourceBlock.checkAndDelete();\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(deleteShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.DELETE,\n      deleteShortcut.name,\n      true,\n    );\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n      Blockly.utils.KeyCodes.BACKSPACE,\n      deleteShortcut.name,\n      true,\n    );\n  }\n\n  /**\n   * Registers all default keyboard shortcut items for keyboard navigation. This\n   * should be called once per instance of KeyboardShortcutRegistry.\n   * @protected\n   */\n  registerDefaults() {\n    this.registerPrevious();\n    this.registerNext();\n    this.registerIn();\n    this.registerOut();\n\n    this.registerDisconnect();\n    this.registerExit();\n    this.registerInsert();\n    this.registerMark();\n    this.registerToolboxFocus();\n    this.registerToggleKeyboardNav();\n\n    this.registerWorkspaceMoveDown();\n    this.registerWorkspaceMoveLeft();\n    this.registerWorkspaceMoveUp();\n    this.registerWorkspaceMoveRight();\n\n    this.registerCopy();\n    this.registerPaste();\n    this.registerCut();\n    this.registerDelete();\n  }\n\n  /**\n   * Removes all the keyboard navigation shortcuts.\n   * @public\n   */\n  dispose() {\n    const shortcutNames = Object.values(Constants.SHORTCUT_NAMES);\n    for (const name of shortcutNames) {\n      Blockly.ShortcutRegistry.registry.unregister(name);\n    }\n    this.removeShortcutHandlers();\n    this.navigation.dispose();\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","STATE","WORKSPACE","FLYOUT","TOOLBOX","SHORTCUT_NAMES","PREVIOUS","NEXT","IN","OUT","INSERT","MARK","DISCONNECT","EXIT","TOGGLE_KEYBOARD_NAV","COPY","CUT","PASTE","DELETE","MOVE_WS_CURSOR_UP","MOVE_WS_CURSOR_DOWN","MOVE_WS_CURSOR_LEFT","MOVE_WS_CURSOR_RIGHT","LOGGING_MSG_TYPE","ERROR","WARN","LOG","FlyoutCursor","constructor","super","next","curNode","getCurNode","newNode","setCurNode","prev","out","registrationType","Type","CURSOR","registrationName","register","pluginInfo","LineCursor","getNextNode_","validLineNode","getType","types","INPUT","getLocation","targetBlock","validInLineNode","getPreviousNode_","node","isValid","location","type","BLOCK","outputConnection","FIELD","Navigation","workspaceStates","loggingCallback","WS_MOVE_DISTANCE","MARKER_NAME","DEFAULT_WS_COORDINATE","Coordinate","WS_COORDINATE_ON_DELETE","wsChangeWrapper","workspaceChangeListener","bind","flyoutChangeWrapper","flyoutChangeListener","workspaces","addWorkspace","workspace","push","flyout","getFlyout","getMarkerManager","registerMarker","addChangeListener","addFlyout","removeWorkspace","workspaceIdx","indexOf","getCursor","disableKeyboardAccessibility","splice","unregisterMarker","removeChangeListener","removeFlyout","setState","state","id","getState","getMarker","flyoutWorkspace","getWorkspace","FlyoutCursorClass","getClass","setCursor","e","getById","workspaceId","keyboardAccessibilityMode","handleBlockDeleteByDrag","BLOCK_CHANGE","element","handleBlockMutation","CLICK","handleWorkspaceClick","TOOLBOX_ITEM_SELECT","handleToolboxCategoryClick","BLOCK_CREATE","handleBlockCreate","mainWorkspace","targetWorkspace","autoClose","targetType","block","getBlockById","blockId","handleBlockClickInFlyout","SELECTED","newElementId","resetFlyout","getToolbox","mutatedBlockId","cursor","getSourceBlock","createBlockNode","workspaceState","newItem","focusToolbox","deletedBlockId","ids","sourceBlock","createWorkspaceNode","isShadow","getParent","getFlyoutCursor","createStackNode","moveCursorOnBlockDelete","deletedBlock","topConnection","previousConnection","createConnectionNode","targetConnection","getRelativeToSurfaceXY","getChildren","toolbox","markAtCursor","getSelectedItem","toolboxItems","getToolboxItems","toolboxItem","isSelectable","selectItemByPosition","focusFlyout","firstFlyoutItem","getContents","button","astNode","createButtonNode","focusWorkspace","hideChaff","reset","setCursorOnWorkspaceFocus","topBlocks","getTopBlocks","wsCoordinates","x","scale","y","length","createTopNode","wsNode","insertFromFlyout","newBlock","createNewBlock","markerNode","tryToConnectMarkerAndCursor","warn","removeMark","isVisible","curBlock","isEnabled","createBlock","render","setConnectionTracking","shouldHide","hide","connectMarkerAndCursor","cursorNode","logConnectionWarning","markerType","cursorType","cursorLoc","markerLoc","isConnection","cursorConnection","markerConnection","connect","STACK","cursorBlock","insertBlock","moveBlockToWorkspace","unplug","moveTo","getWsCoordinate","disconnectChild","movingConnection","destConnection","movingBlock","destBlock","inferiorConnection","getRootBlock","getDescendants","getInferiorConnection","disconnect","movingInferior","destSuperior","getSuperiorConnection","movingSuperior","destInferior","moveAndConnect","checker","getConnectionChecker","reason","canConnectWithReason","getErrorMessage","connection","isSuperior","canConnect","rootBlock","originalOffsetToTarget","originalOffsetInBlock","getOffsetInBlock","clone","positionNearConnection","nextConnection","inputList","inputConnection","disconnectBlocks","log","curConnection","isConnected","superiorConnection","bumpAwayFrom","bringToFront","connectionNode","marker","enableKeyboardAccessibility","msg","console","error","moveWSCursor","xDirection","yDirection","wsCoord","newX","newY","handleEnterForWS","nodeType","showEditor","paste","copyData","isHandled","setGroup","insertPastedBlock","markedNode","triggerButtonCallback","buttonCallback","flyoutButtonCallbacks","callbackKey","Error","dispose","oldDoWorkspaceClick","doWorkspaceClick_","ws","creatorWorkspace_","shiftKey","screenCoord","clientX","clientY","svgMath","screenToWsCoordinates","oldDoBlockClick","doBlockClick_","targetBlock_","isInFlyout","mostRecentEvent_","NavigationController","copyWorkspace","optNavigation","navigation","init","addShortcutHandlers","registerDefaults","onShortcut","fieldColourHandler","fieldDropdownHandler","toolboxHandler","removeShortcutHandlers","shortcut","picker_","name","moveHighlightBy_","menu_","highlightPrevious","highlightNext","selectedItem_","selectPrevious_","selectParent_","selectNext_","selectChild_","enable","disable","fieldShortcutHandler","registerPrevious","previousShortcut","preconditionFn","callback","registry","addKeyMapping","KeyCodes","W","registerToggleKeyboardNav","toggleKeyboardNavShortcut","ctrlShiftK","createSerializedKey","K","CTRL","SHIFT","registerOut","outShortcut","A","registerNext","nextShortcut","S","registerIn","inShortcut","in","D","registerInsert","insertShortcut","options","readOnly","I","registerMark","markShortcut","flyoutCursor","BUTTON","ENTER","registerDisconnect","disconnectShortcut","X","registerToolboxFocus","focusToolboxShortcut","T","registerExit","exitShortcut","ESC","E","registerWorkspaceMoveLeft","wsMoveLeftShortcut","shiftA","registerWorkspaceMoveRight","wsMoveRightShortcut","shiftD","registerWorkspaceMoveUp","wsMoveUpShortcut","shiftW","registerWorkspaceMoveDown","wsMoveDownShortcut","registerCopy","copyShortcut","inProgress","isDeletable","isMovable","toCopyData","ctrlC","C","altC","ALT","metaC","META","registerPaste","pasteShortcut","ctrlV","V","altV","metaV","registerCut","cutShortcut","isFlyout","checkAndDelete","ctrlX","altX","metaX","registerDelete","deleteShortcut","preventDefault","BACKSPACE","shortcutNames","values","unregister"],"sourceRoot":""}