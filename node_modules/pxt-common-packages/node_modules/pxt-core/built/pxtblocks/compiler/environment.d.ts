/// <reference path="../../pxtlib.d.ts" />
import * as Blockly from "blockly";
export interface Environment {
    workspace: Blockly.Workspace;
    options: BlockCompileOptions;
    stdCallTable: pxt.Map<StdFunc>;
    userFunctionReturnValues: pxt.Map<Point>;
    diagnostics: BlockDiagnostic[];
    errors: Blockly.Block[];
    renames: RenameMap;
    stats: pxt.Map<number>;
    enums: pxtc.EnumInfo[];
    kinds: pxtc.KindInfo[];
    idToScope: pxt.Map<Scope>;
    blockDeclarations: pxt.Map<VarInfo[]>;
    blocksInfo: pxtc.BlocksInfo;
    allVariables: VarInfo[];
    placeholders: pxt.Map<pxt.Map<PlaceholderLikeBlock>>;
}
export interface StdFunc {
    f: string;
    comp: pxt.blocks.BlockCompileInfo;
    attrs: ts.pxtc.CommentAttrs;
    isExtensionMethod?: boolean;
    isExpression?: boolean;
    imageLiteral?: number;
    imageLiteralColumns?: number;
    imageLiteralRows?: number;
    hasHandler?: boolean;
    property?: boolean;
    namespace?: string;
    isIdentity?: boolean;
}
export interface RenameMap {
    oldToNew: pxt.Map<string>;
    takenNames: pxt.Map<boolean>;
    oldToNewFunctions: pxt.Map<string>;
}
export interface PlaceholderLikeBlock extends Blockly.Block {
    p?: Point;
}
export interface BlockCompilationResult {
    source: string;
    sourceMap: pxt.blocks.BlockSourceInterval[];
    stats: pxt.Map<number>;
    diagnostics: BlockDiagnostic[];
}
export interface BlockCompileOptions {
    emitTilemapLiterals?: boolean;
}
export declare class Point {
    link: Point;
    type: string;
    parentType?: Point;
    childType?: Point;
    isArrayType?: boolean;
    constructor(link: Point, type: string, parentType?: Point, childType?: Point, isArrayType?: boolean);
}
export interface Scope {
    parent?: Scope;
    firstStatement: Blockly.Block;
    declaredVars: pxt.Map<VarInfo>;
    referencedVars: number[];
    assignedVars: number[];
    children: Scope[];
}
export declare enum BlockDeclarationType {
    None = 0,
    Argument = 1,
    Assigned = 2,
    Implicit = 3
}
export interface BlockDiagnostic {
    blockId: string;
    message: string;
}
export interface VarInfo {
    name: string;
    id: number;
    escapedName?: string;
    type?: Point;
    alreadyDeclared?: BlockDeclarationType;
    firstReference?: Blockly.Block;
    isAssigned?: boolean;
    isFunctionParameter?: boolean;
}
export interface GrayBlock extends Blockly.BlockSvg {
    setPythonEnabled(enabled: boolean): void;
}
export interface GrayBlockStatement extends GrayBlock {
    domToMutation(xmlElement: Element): void;
    mutationToDom(): Element;
    getLines: () => string[];
    declaredVariables: string;
}
export declare function emptyEnv(w: Blockly.Workspace, options: BlockCompileOptions): Environment;
export declare function mkEnv(w: Blockly.Workspace, blockInfo?: pxtc.BlocksInfo, options?: BlockCompileOptions): Environment;
