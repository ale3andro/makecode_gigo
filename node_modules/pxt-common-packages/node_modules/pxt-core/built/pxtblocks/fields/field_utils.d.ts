import * as Blockly from "blockly";
import { FieldTilemap } from "./field_tilemap";
import { FieldTileset } from "./field_tileset";
export interface FieldCustom {
    isFieldCustom_: boolean;
    saveOptions?(): pxt.Map<string | number | boolean>;
    restoreOptions?(map: pxt.Map<string | number | boolean>): void;
}
export interface FieldCustomOptions {
    blocksInfo: any;
    colour?: string | number;
    label?: string;
    type?: string;
}
export interface FieldCustomDropdownOptions extends FieldCustomOptions {
    data?: any;
}
export interface FieldCustomConstructor {
    new (text: string, options: FieldCustomOptions, validator?: Function): FieldCustom & Blockly.Field;
}
export interface PXTBlockData {
    commentRefs: string[];
    fieldData: pxt.Map<string>;
}
export interface AssetSaveState {
    version: number;
    assetType: pxt.AssetType;
    jres: pxt.Map<pxt.JRes>;
    assetId: string;
}
export declare namespace svg {
    function hasClass(el: SVGElement, cls: string): boolean;
    function addClass(el: SVGElement, cls: string): void;
    function removeClass(el: SVGElement, cls: string): void;
}
export declare function parseColour(colour: string | number): string;
/**
 * Converts a bitmap into a square image suitable for display. In light mode the preview
 * is drawn with no transparency (alpha is filled with background color)
 */
export declare function bitmapToImageURI(frame: pxt.sprite.Bitmap, sideLength: number, lightMode: boolean): string;
export declare function tilemapToImageURI(data: pxt.sprite.TilemapData, sideLength: number, lightMode: boolean): string;
export declare function songToDataURI(song: pxt.assets.music.Song, width: number, height: number, lightMode: boolean, maxMeasures?: number): string;
export interface FieldEditorReference<U extends Blockly.Field> {
    block: Blockly.Block;
    field: string;
    ref: U;
    parsed?: pxt.sprite.TilemapData;
}
export declare function getAllBlocksWithTilemaps(ws: Blockly.Workspace): FieldEditorReference<FieldTilemap>[];
export declare function getAllBlocksWithTilesets(ws: Blockly.Workspace): FieldEditorReference<FieldTileset>[];
export declare function needsTilemapUpgrade(ws: Blockly.Workspace): boolean;
export declare function updateTilemapXml(dom: Element, proj: pxt.TilemapProject): void;
export declare function getAllFields<U extends Blockly.Field>(ws: Blockly.Workspace, predicate: (field: Blockly.Field) => boolean): FieldEditorReference<U>[];
export declare function getAllReferencedTiles(workspace: Blockly.Workspace, excludeBlockID?: string): pxt.Tile[];
export declare function getTilesReferencedByTilesets(workspace: Blockly.Workspace): pxt.Tile[];
export declare function getTemporaryAssets(workspace: Blockly.Workspace, type: pxt.AssetType): pxt.Asset[];
export declare function getAssetSaveState(asset: pxt.Asset): AssetSaveState;
export declare function loadAssetFromSaveState(serialized: AssetSaveState): pxt.Asset;
export declare const FIELD_EDITOR_OPEN_EVENT_TYPE = "field_editor_open";
export declare class FieldEditorOpenEvent extends Blockly.Events.UiBase {
    type: string;
    blockId: string;
    isOpen: boolean;
    constructor(block: Blockly.Block, isOpen: boolean);
}
export declare function setMelodyEditorOpen(block: Blockly.Block, isOpen: boolean): void;
export declare function workspaceToScreenCoordinates(ws: Blockly.WorkspaceSvg, wsCoordinates: Blockly.utils.Coordinate): Blockly.utils.Coordinate;
export declare function getBlockData(block: Blockly.Block): PXTBlockData;
export declare function setBlockData(block: Blockly.Block, data: PXTBlockData): void;
export declare function setBlockDataForField(block: Blockly.Block, field: string, data: string): void;
export declare function getBlockDataForField(block: Blockly.Block, field: string): string;
export declare function deleteBlockDataForField(block: Blockly.Block, field: string): void;
export declare function clearDropDownDiv(): void;
